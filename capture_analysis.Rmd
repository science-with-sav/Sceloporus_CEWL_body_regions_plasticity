---
title: "Cal Poly Herpetology CURE - Capture Data Analyses"
author: "Savannah Weaver"
date: "June 2021"
output: 
  pdf_document:
    toc: TRUE
---


# Packages

```{r setup, include=FALSE}
if (!require("tidyverse")) install.packages("tidyverse")
library("tidyverse") # workflow and plots
if (!require("zoo")) install.packages("zoo")
library("zoo") # interpolation using na.approx
if (!require("weathermetrics")) install.packages("weathermetrics")
library("weathermetrics") # F to C conversion
if (!require("PerformanceAnalytics")) install.packages("PerformanceAnalytics") 
library("PerformanceAnalytics") # pretty multicollinearity plots
if (!require("UsingR")) install.packages("UsingR")
library("UsingR")
if (!require("MASS")) install.packages("MASS")
library("MASS") # model selection & box-cox
if (!require("lme4")) install.packages("lme4")
library("lme4") # for LMMs
if (!require("lmerTest")) install.packages("lmerTest")
library("lmerTest") # for p-values
if (!require("onewaytests")) install.packages("onewaytests")
library("onewaytests") # for Brown-Forsythe test
if (!require("ggpubr")) install.packages("ggpubr")
library("ggpubr") # for ggplot multi-figures
if (!require("broom")) install.packages("broom")
library("broom") # lmer model export
```


# Background and Goals

This data was collected April - May 2021 during a course-based undergraduate research experience (CURE) in Herpetology, taught by Emily Taylor at Cal Poly, San Luis Obispo. This part of the study was conducted to describe the variation in hydrophysiology in *Sceloporus occidentalis* and to investigate what drives that variation. Please refer to **doi:** for full details.

In this document, we investigate differences in cutaneous evaporative water loss (CEWL) across body regions and dependent on environment, body size, condition, and hydration. 


# Data

### Morphometrics and Blood Data

This data was collected upon capture of each lizard.

Variables in this dataframe:
- date
- collection/capture time for each lizard
- individual ID for each lizard
- sock ID used to capture each lizard (removed, not relevant to analyses)
- SVL = snout-vent length
- mass in grams
- sex
- if female, whether or not gravid (with eggs)
- which eye the blood sample was taken from
- percent hematocrit = percent of blood that's red blood cells
- osmolality = a proxy of hydration, should be inversely related to water content of a lizard (this is the average of 1-3 replicates)
- cloacal temperature at the time of CEWL measurement
- processing time for each lizard, when all measurements were finished
- hemolyzed = whether or not red blood cells burst and contaminated plasma

Before loading in this data, some incorrectly-measured hematocrit and osmolality were omitted:
- hematocrit for individuals 1-16, due to observer error
- osmolality for individual 19, due to instrumental error

```{r morpho blood data}
# load and format data
morpho_blood_dat <- read.csv("./data/Herpetology_Data.csv", # filename
                             na.strings=c("","NA") # fix empty cells
                             ) %>%
  dplyr::mutate(# put date and time together
                collect_date_time = (paste(date, collect_time)), 
                # replace some date-time values that have missing times
                collect_date_time = replace(collect_date_time, 
                                            collect_date_time == "4/5/21 NA", NA),
                # correctly format date-time variable
                collect_date_time = as.POSIXct(collect_date_time, 
                                               format = "%m/%d/%y %H:%M"),
                # correctly format date-only variable
                date = as.Date(date, format = "%m/%d/%y"),
                # correctly format collection time variable
                # format extracts just time after posix adds arbitrary date
                collect_time = (as.POSIXct(collect_time, format = "%H:%M")),
                # correctly format processing time variable
                processing_time = (as.POSIXct(processing_time, format = "%H:%M")),
                # set individual_ID variable as a factor, not numeric
                individual_ID = as.factor(individual_ID),
                # set sex variable as a factor, not character
                sex_M_F = as.factor(sex_M_F),
                # set gravidity variable as a factor, not character
                gravid_Y_N = as.factor(gravid_Y_N),
                # set blood sample eye variable as a factor, not character
                blood_sample_eye = as.factor(blood_sample_eye),
                # set hemolyzed variable as a factor, not character
                hemolyzed = as.factor(hemolyzed),
                # compute holding time as capture time - cloacal measurement time:
                hold_time = as.numeric(processing_time - collect_time)
                ) %>%
  # remove two columns not relevant for statistics
  dplyr::select(-sock_ID, -notes)

# check
summary(morpho_blood_dat)
unique(morpho_blood_dat$date)

# get info
morpho_blood_dat %>%
  dplyr::filter(complete.cases(hold_time)) %>%
  summarise(mean_hold_time_minutes = mean(hold_time),
            mean_hold_time_hrs = mean_hold_time_minutes/60)

# export
#write.csv(morpho_blood_dat, "exported_data/capture_hydration.csv")
```

I want to test if any IDs are missing, and which ones if so.

```{r}
test <- c(seq(1, 150, by = 1))
lost <- test[test %nin% morpho_blood_dat$individual_ID]
lost
```

Individuals 23 and 56 actually both do not exist because those numbers were skipped when assigning IDs, so we have all the individuals measured in the dataframe.




### CEWL Data

First, load it all in and merge.

Variables in this dataframe are:
- date
- time
- date_time combined variable
- individual_ID for each lizard measured
- region = where on the body CEWL was measured
- TEWL_g_m2h = CEWL measurement value in grams/sq-meter/hour
- ambient_temp_C = temperature when and where measurement was taken
- ambient_RH_percent = relative humidity when and where measurement was taken
- abs_humidity = computed from RH using formula on this website: https://carnotcycle.wordpress.com/2012/08/04/how-to-convert-relative-humidity-to-absolute-humidity/

```{r CEWL data}
# week 1
CEWL_April_05 <- read.csv("./data/capture_CEWL/4-5-21-CEWL.csv", # filename
                          na.strings=c("","NA")) %>% # fix empty cells
  # rename and select the pertinent variables/cols
  # I have to do this for each one 
  # so they all have the same number of columns for joining
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 2
CEWL_April_19 <- read.csv("./data/capture_CEWL/4-19-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 3
CEWL_April_26 <- read.csv("./data/capture_CEWL/4-26-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 4
CEWL_May_3 <- read.csv("./data/capture_CEWL/5-3-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 5
CEWL_May_10 <- read.csv("./data/capture_CEWL/5-10-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 6
CEWL_May_17 <- read.csv("./data/capture_CEWL/5-17-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# merge all CEWL datafiles & reformat
CEWL <- CEWL_April_05 %>% # week 1
  # join with weeks 2-6
  rbind(., CEWL_April_19, 
        CEWL_April_26,
        CEWL_May_3,
        CEWL_May_10,
        CEWL_May_17
        ) %>%
  # remove any unsuccessful measurements
  dplyr::filter(Status == "Normal") %>%
  # extract individual_ID and region separately from the "ID" variable
  separate(ID, c("individual_ID", "region")) %>%
  # reformat data
  dplyr::mutate(# paste and format date-time variable
                CEWL_date_time = as.POSIXct(paste(date, Time), 
                                            format = "%m/%d/%y %I:%M:%S %p"),
                # reformat date only
                date = as.Date(date, format = "%m/%d/%y"),
                # reformat time 
                # format extracts just time after posix adds arbitrary date
                # but then it's a character again... 
                Time = format(as.POSIXct(Time, format = "%I:%M:%S %p"), 
                              format = "%H:%M:%S"),
                # format individual ID as a factor
                individual_ID = as.factor(individual_ID),
                # set body region as a factor variable after getting only the consistent characters due to typos
                region = as.factor(substring(region, 1, 4)),
                # convert RH to absolute humidity
                abs_humidity_g_m3 = ((6.112 * exp((17.67*ambient_temp_C)/(ambient_temp_C + 243.5)) * ambient_RH_percent * 2.1674) / (273.15 + ambient_temp_C))
                ) %>%
  # remove cols not relevant to stats
  dplyr::select(-Status) %>%
  # remove any rows with missing values
  dplyr::filter(complete.cases(.))
summary(CEWL)
```


Write CEWL dataframe as a csv for use in other analyses:

```{r}
#write.csv(CEWL, "exported_data/capture_CEWL.csv")
```




### Weather Data

This data was obtained from http://www.itrc.org/databases/precip/ (Adcon Server Data) to test the effect of ambient conditions on CEWL. This is different from the ambient conditions already measured with CEWL, which are the temperature and humidity around the measurement device at the time of measurement. We think that the temperature, humidity, wind speed, and solar radiation the lizard was exposed to prior to capture may also affect CEWL.

We didn't have a daylight savings time switchover during this study, so we don't need to worry about incorporating. 

```{r}
# load in csvs and put all in one dataframe
weather <- read.csv("./data/weather/4_5Weather.csv", sep = ';') %>%
  rbind(read.csv("./data/weather/4_19Weather.csv", sep = ';')) %>%
  rbind(read.csv("./data/weather/5_3Weather.csv", sep = ';')) %>%
  rbind(read.csv("./data/weather/5_10Weather.csv", sep = ';')) %>%
  rbind(read.csv("./data/weather/5_17Weather.csv", sep = ';')) %>%
  # add a variable for combined date-time
  mutate(collect_date_time = as.POSIXct(paste(Date, Time),
                                format = "%m/%d/%y %I:%M:%S %p")) %>%
  # remove lonely date and time
  dplyr::select(-Date, -Time)
```

The weather data is only every 15 minutes, but I want to match it to any minute measurement, so I need to interpolate the values for each minute.

First, make a separate dataframe with every minute for each of those days.

```{r}
all_times <- data.frame(collect_date_time = c(# April 5
                           seq(from = as.POSIXct("2021-04-05 10:00"),
                               to = as.POSIXct("2021-04-05 16:00"),
                               by="min"),
                           # April 19
                           seq(from = as.POSIXct("2021-04-19 10:00"),
                               to = as.POSIXct("2021-04-19 16:00"),
                               by="min"),
                           # April 26
                           seq(from = as.POSIXct("2021-04-26 10:00"),
                               to = as.POSIXct("2021-04-26 16:00"),
                               by="min"),
                           # May 3
                           seq(from = as.POSIXct("2021-05-03 10:00"),
                               to = as.POSIXct("2021-05-03 16:00"),
                               by="min"),
                           # May 10
                           seq(from = as.POSIXct("2021-05-10 10:00"),
                               to = as.POSIXct("2021-05-10 16:00"),
                               by="min"),
                           # May 17
                           seq(from = as.POSIXct("2021-05-17 10:00"),
                               to = as.POSIXct("2021-05-17 16:00"),
                               by="min")
                           ))

```

Next, merge the weather data into the times dataframe and interpolate the temperature and humidity between measurements.

```{r}
all_times_weather <- all_times %>% # time only dataframe
  # add weather measurements based on matching date-time
  left_join(weather, by = 'collect_date_time') %>%
  # convert temperature units, thanks America
  mutate(temp_C = fahrenheit.to.celsius(Temperature_F, round = 2),
         # interpolate temperatures
         temp_C_interpol = na.approx(temp_C),
         # interpolate humidities
         RH_percent_interpol = na.approx(RH_percent),
         # interpolate Wind Speeds
         Wind_mph_interpol = na.approx(Wind_Speed_mph),
         # interpolate solar radiation
         Solar_rad_Wm2_interpol = na.approx(Pyranometer_W_m),
         # compute absolute humidity
         abs_humidity_g_m3_interpol = ((6.112 * exp((17.67*temp_C_interpol)/(temp_C_interpol + 243.5)) * RH_percent_interpol * 2.1674) / (273.15 + temp_C_interpol))
         ) %>%
  # keep only the relevant variables
  dplyr::select(collect_date_time, 
                temp_C_interpol, 
                RH_percent_interpol, 
                abs_humidity_g_m3_interpol,
                Wind_mph_interpol, 
                Solar_rad_Wm2_interpol)
summary(all_times_weather)
```



## Compute Scaled Mass Index

This is also known as the body condition index, or log-log residuals.

I calculate as described by: Peig, J., & Green, A. J. (2009). New perspectives for estimating body condition from mass/length data: The scaled mass index as an alternative method. Oikos, 118(12), 1883–1891. https://doi.org/10.1111/j.1600-0706.2009.17643.x

### Step 1: mass ~ SVL

plot:

```{r}
morpho_blood_dat %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = mass_g, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = mass_g, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("Mass") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0
)
```

create a simple linear regression 

```{r}
mass_SVL_SLR <- lm(data = morpho_blood_dat, mass_g ~ SVL_mm)
summary(mass_SVL_SLR)
```

look for outliers by calculating residuals

```{r}
mass_SVL_SLR_residuals <- morpho_blood_dat %>%
  # not working with function, so just compute by hand... 
  mutate(#y_hat = predict(mass_SVL_SLR),
         #e = residuals(mass_SVL_SLR),
         y_hat = 0.40988*SVL_mm - 16.04514,
         e = y_hat - mass_g
         ) %>%
  dplyr::filter(e < 3 & e > -3)
```

plot residuals

```{r}
ggplot(data = mass_SVL_SLR_residuals, 
       aes(x = e)) +
  geom_histogram() + 
  theme_classic() + 
  xlab("residuals (e)")
ggplot(data = mass_SVL_SLR_residuals, 
       aes(x = e)) +
  geom_boxplot() + 
  theme_classic() + 
  scale_x_continuous(breaks = c(seq(-5, 5, 1))) +
  xlab("residuals (e)") +
  geom_vline(xintercept = -3, lty = 1) +
  geom_vline(xintercept = 3, lty = 1)
```

From the histogram, there are clearly points disconnected from the main curve. In the boxplot, we can distinguish that those outlying points have residuals <-3.5 and >3, so I'll go back and filter those out in the code chunk before making the distribution plots. Now the boxplot has no dots outside the main distribution.

And, check mean residual value:

```{r}
mass_SVL_SLR_residuals %>%
  summarise(mean_res = mean(e),
            med = median(e))
```

Not zero, which is not ideal, but pretty close. 

Next, check for high leverage points:

```{r}
# compute values for observations 
high_leverage <- data.frame(H = hatvalues(mass_SVL_SLR)
                            ) %>% mutate(row = rownames(.))

# compute cutoff value 
h_bar <- (3*sum(high_leverage$H))/nrow(high_leverage)

# add to original dataframe 
# see which observations have extremely high leverage (if any)
high_leverage_dat <- mass_SVL_SLR_residuals %>%
  mutate(row = rownames(.)) %>%
  left_join(., high_leverage, by = "row") %>%
  dplyr::filter(H > h_bar) 
high_leverage_dat
```

The points for individuals 4, 5, 6, 8, 9, 57, 64, 67, 87, and 123 seem to be high-leverage, so we will try removing them.

Check for influential points based on Cook's distance:

```{r}
# get Cook's distance 
cooks <- data.frame(c = cooks.distance(mass_SVL_SLR) # specify model name 
                    ) %>% mutate(row = rownames(.))

# add to original dataframe 
influential <- mass_SVL_SLR_residuals %>%
  mutate(row = rownames(.)) %>% 
  left_join(., cooks, by = "row")

# see moderately influential points 
cook_mod_inf <- influential %>% 
  dplyr::filter(c>0.5) 
cook_mod_inf
```

There are no even moderately-infuential points, at least based on Cook's distance, so there's nothing to potentially remove.

Create new SLR and check mean residual value after removing outliers and high leverage points:

```{r}
# create new dataframe with filtered data 
cleaned_SMI_dat <- mass_SVL_SLR_residuals %>% # already had outliers removed
  mutate(row = rownames(.)) %>%
  # add high leverage point info
  left_join(., high_leverage, by = "row") %>%
  # remove high leverage points
  dplyr::filter(H < h_bar) 

# model
mass_SVL_SLR2 <- lm(data = cleaned_SMI_dat, mass_g ~ SVL_mm)
summary(mass_SVL_SLR2)

# compute residuals
mass_SVL_SLR2_residuals <- cleaned_SMI_dat %>%
  mutate(y_hat = predict(mass_SVL_SLR2),
         e = residuals(mass_SVL_SLR2))

# check residuals values
mass_SVL_SLR2_residuals %>%
  summarise(mean_res = mean(e),
            med = median(e))
```

The residuals are much much smaller, so I believe it is the right choice to remove the high leverage points. The "cleaned_SMI_dat" will be used to calculate the equation for SMI.
 
 
### Step 2: make log-log relationship

plot and calculate SLR for filtered data

```{r}
cleaned_SMI_dat %>% 
  ggplot(data = .) + 
  geom_point(aes(x = log(SVL_mm),
                 y = log(mass_g), 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = log(SVL_mm), 
                  y = log(mass_g), 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("log-SVL") + 
  ylab("log-Mass") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0
)
```

SLR

```{r}
log_mass_SVL_SLR <- lm(data = cleaned_SMI_dat, 
                       log(mass_g) ~ log(SVL_mm))
summary(log_mass_SVL_SLR)
```

compute standardized major axis using this regression equation:

```{r}
r <- sqrt(0.8391) # Pearson's correlection coefficient (sqrt of R-squared)
b_OLS <- 3.0611 # regression slope
b_SMA <- b_OLS/r
```

also get a value for L0:

```{r}
L0 <- mean(cleaned_SMI_dat$SVL_mm)
```


### Step 3: calculate scaled mass index

(And join weather data.)

```{r}
morpho_blood_SMI <- morpho_blood_dat %>%
  mutate(SMI = mass_g * ((L0/SVL_mm) ^ b_SMA)) %>%
  left_join(all_times_weather, 
            by = c("collect_date_time")
            )
```


### Check

Look at the difference between regular mass and SMI:

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = mass_g,
                 y = SMI, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = mass_g, 
                  y = SMI, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Mass") + 
  ylab("SMI") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0
)
```








### Join Data 

Add CEWL and morpho_blood_SMI data together. 

```{r}
CEWL_data_full <- CEWL %>%
  left_join(morpho_blood_SMI, 
            by = c("date", "individual_ID")
            ) 
summary(CEWL_data_full)
```


### Final Formatting

redo the levels for body region:

```{r}
CEWL_data_full$region <- factor(CEWL_data_full$region,
                                levels = c("dors", "vent", 
                                           "head", "dewl", "mite"),
                                labels = c("Dorsum", "Ventrum", "Head",
                                           "Dewlap", "Mite Patch")
                                )
head(CEWL_data_full)
```

NOTE: running this more than once overrides things, so be careful


# Check Data Distributions

## Histograms & Q-Q Plots

### SVL

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = SVL_mm)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("SVL (mm)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$SVL_mm)
# Normality test if p > .05, data is normal. Data is not normal.
shapiro.test(morpho_blood_SMI$SVL_mm)
```

### Mass

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = mass_g)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Mass (g)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$mass_g)
# Normality test if p > .05, data is normal. Data is not normal.
shapiro.test(morpho_blood_SMI$mass_g)
```

### SMI

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = SMI)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Scaled Mass Index (g)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$SMI)
# Normality test if p > .05, data is normal. Data is not normal.
shapiro.test(morpho_blood_SMI$SMI)
```

SMI is one of the few variables actually normally distributed!


### Hematocrit 

looks pretty normally distributed around ~35%, but not statistically normal

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = hematocrit_percent)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Hematocrit (%)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$hematocrit_percent)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$hematocrit_percent)
```

### Osmolality 

pretty normally distributed around ~370! :D

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = osmolality_mmol_kg)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Osmolality (mmol/kg)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$osmolality_mmol_kg)
# Normality test if p > .05, data is normal. Data is normal
shapiro.test(morpho_blood_SMI$osmolality_mmol_kg)
```

### Cloacal Temperature 

seems normally distributed, but not normal

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = cloacal_temp_C)) +
  geom_histogram(color = "black", fill="steelblue", bins=10) + 
  theme_classic() +
  xlab("cloacal temperature (C)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$cloacal_temp_C)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$cloacal_temp_C)
```




### CEWL

```{r}
CEWL_data_full %>%
  ggplot(., aes(x = TEWL_g_m2h)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("TEWL_g_m2h") + 
  ylab("Count")
simple.eda(CEWL_data_full$TEWL_g_m2h)
CEWL_data_full %>%
  ggplot(., aes(x = TEWL_g_m2h)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("TEWL_g_m2h") + 
  ylab("Count") + 
  facet_wrap(~region)

# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(CEWL_data_full$TEWL_g_m2h)

# Log transformation
shapiro.test(log(CEWL_data_full$TEWL_g_m2h))
# p-value improves to  0.00548, but is still significant
```


### Capture Temperature 

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = temp_C_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Temperature (C)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$temp_C_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$temp_C_interpol)

# log transform 
shapiro.test(log(morpho_blood_SMI$temp_C_interpol))
```

### Capture Absolute Humidity


```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = abs_humidity_g_m3_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Absolute Humidity (g/m^3)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$abs_humidity_g_m3_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$abs_humidity_g_m3_interpol)

# Doesn't fix non normality
shapiro.test(log(morpho_blood_SMI$abs_humidity_g_m3_interpol))
```

### Wind Speed at Capture

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = Wind_mph_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Wind Speed (mph)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$Wind_mph_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$Wind_mph_interpol)

# ln transformation doesn't fix non normality
shapiro.test(log(morpho_blood_SMI$Wind_mph_interpol))
```

### Solar Radiation at Capture

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = Solar_rad_Wm2_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Solar Radiation (W/m^2)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$Solar_rad_Wm2_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$Solar_rad_Wm2_interpol)

# Doesn't fix non normality
shapiro.test(log(morpho_blood_SMI$Solar_rad_Wm2_interpol))
```

## Conclusion

Osmolality and SMI were the only normally distributed variables. 

The following variables each had non-normal distributions:
- SVL (skewed left)
- mass (skewed left)
- hct (looks like a bell curve, but not very pretty)
- cloacal temp (skewed right)
- CEWL (skewed right, overall and for each region individually)
- capture temp (multimodal)
- capture humidity (multimodal and skewed left)
- wind speed (multimodal but sorta bell curve)
- solar radiation (multimodal)

All of the non-normal variables are likely to need transformation if they're included in the final model.



# Basic Figs & LMs

## What affects osmolality & hematocrit?

### Hct ~ SVL


```{r}
# plot
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = hematocrit_percent, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("Hct") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
lm_hct_SVL <- lm(hematocrit_percent ~ SVL_mm,
           data = morpho_blood_SMI)
summary(lm_hct_SVL)
```



### Osml ~ SVL

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = osmolality_mmol_kg, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
lm_osml_SVL <- lm(osmolality_mmol_kg ~ SVL_mm,
           data = morpho_blood_SMI)
summary(lm_osml_SVL)
```


### Hct ~ SMI

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SMI,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) +
  stat_smooth(aes(x = SMI, 
                  y = hematocrit_percent, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Scaled Mass Index") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
lm_hct_mass <- lm(hematocrit_percent ~ SMI,
           data = morpho_blood_SMI)
summary(lm_hct_mass)
```

### Osml ~ SMI


```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SMI,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SMI, 
                  y = osmolality_mmol_kg), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = "gray",
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Scaled Mass Index") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
lm_osml_mass <- lm(osmolality_mmol_kg ~ SMI,
           data = morpho_blood_SMI)
summary(lm_osml_mass)
```


### Hct ~ Sex

males have significantly higher hematocrit %

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = sex_M_F, 
                   y = hematocrit_percent, 
                   color = sex_M_F
                   ), 
               size = 1,
               alpha = 1) + 
  theme_classic() + 
  xlab("Sex") + 
  ylab("Hematocrit (%)") + 
  annotate("text", x = 1.5, y = 45, 
           label = "paste(italic(p), \" = 0.02\")", 
           parse = TRUE,
           size = 6) +
  ylim(10, 50) +
  scale_x_discrete(labels = c("F" = "Female",
                              "M" = "Male")) +
  scale_color_brewer(palette = "Set2") +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> hct_sex_fig
hct_sex_fig

# export figure
ggsave(filename = "hct_sex_fig.jpeg",
       plot = hct_sex_fig,
       path = "./final_figures",
       device = "jpeg",
       dpi = 1200,
       width = 6, height = 4)

# lms
lm_hct_sex_mass <- lm(hematocrit_percent ~ sex_M_F*mass_g - mass_g,
           data = morpho_blood_SMI)
summary(lm_hct_sex_mass)
lm_hct_sex <- lm(hematocrit_percent ~ sex_M_F,
           data = morpho_blood_SMI)
summary(lm_hct_sex)
```

Hematocrit is significantly predicted by sex, but the interaction between sex and mass is ~nonexistent. 


### Osml ~ Sex

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = sex_M_F, 
                   y = osmolality_mmol_kg, 
                   color = sex_M_F
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Sex", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Sex") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_osml_sex <- lm(osmolality_mmol_kg ~ sex_M_F,
           data = morpho_blood_SMI)
summary(lm_osml_sex)
```

### Hct ~ Gravidity

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(sex_M_F == 'F') %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = gravid_Y_N, 
                   y = hematocrit_percent, 
                   color = gravid_Y_N
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Gravid", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Gravid (Females Only)") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_hct_gravid <- lm(hematocrit_percent ~ gravid_Y_N,
           data = morpho_blood_SMI)
summary(lm_hct_gravid)
```

### Osml ~ Gravidity

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(sex_M_F == 'F') %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = gravid_Y_N, 
                   y = osmolality_mmol_kg, 
                   color = gravid_Y_N
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Gravid", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Gravid (Females Only)") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_osml_gravid <- lm(osmolality_mmol_kg ~ gravid_Y_N,
           data = morpho_blood_SMI)
summary(lm_osml_gravid)
```

### Hct ~ Sample Eye

Actually, any blood samples not taken from the right eye ended up being excluded or didn't have hematocrit values, so we can't test this difference.

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(blood_sample_eye %in% c("R", "L")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = blood_sample_eye, 
                   y = hematocrit_percent, 
                   color = blood_sample_eye
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Blood Sample Eye") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)
```


### Osml ~ Sample Eye

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(blood_sample_eye %in% c("R", "L")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = blood_sample_eye, 
                   y = osmolality_mmol_kg, 
                   color = blood_sample_eye
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Blood Sample Eye") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_osml_eye <- lm(osmolality_mmol_kg ~ blood_sample_eye,
           data = morpho_blood_SMI)
summary(lm_osml_eye)
summary(morpho_blood_SMI$blood_sample_eye)
```

There IS a significant difference, but upon further inspection, the number of blood draws taken from the right postorbital sinus vs left or both is so uneven, this would be unhelpful in the actual model.

### Hct ~ Hemolyzed/Not

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(hemolyzed %in% c("Y", "N")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = hemolyzed, 
                   y = hematocrit_percent, 
                   color = hemolyzed
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1", "green4", "salmon1") ) +
  theme_classic() + 
  xlab("Whether or not Sample Hemolyzed") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_hct_hem <- lm(hematocrit_percent ~ hemolyzed,
           data = morpho_blood_SMI)
summary(lm_hct_hem)
```



### Osml ~ Hemolyzed/Not

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(hemolyzed %in% c("Y", "N")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = hemolyzed, 
                   y = osmolality_mmol_kg, 
                   color = hemolyzed
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1", "green4", "salmon1") ) +
  theme_classic() + 
  xlab("Whether or not Sample Hemolyzed") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_osml_hem <- lm(osmolality_mmol_kg ~ hemolyzed,
           data = morpho_blood_SMI)
summary(lm_osml_hem)
```

Osmolality in hemolyzed samples versus not are significantly different! This is an unfortunate trait of the dataset, and not something we are specifically interested in testing, so we will include it as a random factor in the LMM.

### Hct ~ Week

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = hematocrit_percent, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  theme_classic() + 
  xlab("Sampling Date") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
lm_hct_wk <- lm(hematocrit_percent ~ date,
           data = morpho_blood_SMI)
summary(lm_hct_wk)
```



### Osml ~ Week

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = osmolality_mmol_kg, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  theme_classic() + 
  xlab("Date") + 
  ylab("Osmolality (mmol / kg)") + 
  annotate("text", x = 1, y = 365, label = "a", size = 6) +
  annotate("text", x = 2, y = 390, label = "b", size = 6) +
  annotate("text", x = 3, y = 437, label = "c", size = 6) +
  annotate("text", x = 4, y = 427, label = "c", size = 6) +
  annotate("text", x = 5, y = 417, label = "d", size = 6) +
  annotate("text", x = 6, y = 447, label = "d", size = 6) +
  scale_x_discrete(labels = c("2021-04-05" = "Apr 5", 
                              "2021-04-19" = "Apr 19",
                              "2021-04-26" = "Apr 26",
                              "2021-05-03" = "May 3", 
                              "2021-05-10" = "May 10",
                              "2021-05-17" = "May 17")) +
  scale_color_brewer(palette = "Set2") +
  ylim(300, 450) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> osml_date_fig
osml_date_fig

# export figure
#ggsave(filename = "osml_date_fig.tiff",
 #      plot = osml_date_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)

# lm
lm_osml_wk <- glm(osmolality_mmol_kg ~ date,
           data = morpho_blood_SMI)
summary(lm_osml_wk)
```

Osmolality was VERY different by week, and that was not easily attributable to climate factors (see below). We also experienced technical difficulties with the osmometer between some weeks, so some of the variation may be attributable to technical error. Thus date/week will be a good random factor to include in the LMM.

distinguish pairwise differences using an ANOVA:

```{r}
osml_date_aov <- aov(osmolality_mmol_kg ~ as.factor(date), 
                     data = morpho_blood_SMI)
TukeyHSD(osml_date_aov)
```


### Osml, Humidity, Week

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = osmolality_mmol_kg, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  geom_jitter(aes(x = as.factor(date), 
                  # added multiplier to put on same axis range
                   y = 35*abs_humidity_g_m3_interpol)) +
  theme_classic() + 
  xlab("Sampling Date") + 
  ylab("Osmolality (mmol/kg)") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)
```


### Osml ~ Abs. Humidity

```{r}
my_blue <- RColorBrewer::brewer.pal(8, "Set2")[3]
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = abs_humidity_g_m3_interpol,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = abs_humidity_g_m3_interpol, 
                  y = osmolality_mmol_kg), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = my_blue,
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab(bquote('Absolute Humidity at Capture (g/'*m^2*')')) + 
  #ylab("Osmolality (mmol/kg)") + 
  ylab("") +
  xlim(8, 12) +
  ylim(300, 450) +
  annotate("text", x = 8.4, y = 450, 
           label = "paste(italic(R) ^ 2, \" = 0.04\")", 
           parse = TRUE,
           size = 6) +
  annotate("text", x = 8.4, y = 435, 
           label = "paste(italic(p), \" = 0.01\")", 
           parse = TRUE,
           size = 6) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
) -> osml_abhum_fig
osml_abhum_fig

# export figure
#ggsave(filename = "osml_abhum_fig.jpeg",
 #      plot = osml_abhum_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 6, height = 4)

# lm
lm_osml_abshum <- lm(osmolality_mmol_kg ~ abs_humidity_g_m3_interpol,
           data = morpho_blood_SMI)
summary(lm_osml_abshum)
```

*positive* correlation...




### Hct ~ Humidity

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = abs_humidity_g_m3_interpol,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = abs_humidity_g_m3_interpol, 
                  y = hematocrit_percent), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = "blue",
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient Absolute Humidity at Capture (%)") + 
  ylab("Hematocrit (%)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
lm_hct_RH <- lm(hematocrit_percent ~ abs_humidity_g_m3_interpol,
           data = morpho_blood_SMI)
summary(lm_hct_RH)
```


### Hct ~ Temperature

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = temp_C_interpol,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = temp_C_interpol, 
                  y = hematocrit_percent), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = "maroon",
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient Temperature at Capture (C)") + 
  ylab("Hematocrit (%)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
lm_hct_temp <- lm(hematocrit_percent ~ temp_C_interpol,
           data = morpho_blood_SMI)
summary(lm_hct_temp)
```

### Osml ~ Temperature

```{r}
my_red <- RColorBrewer::brewer.pal(8, "Set2")[4]

morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = temp_C_interpol,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = temp_C_interpol, 
                  y = osmolality_mmol_kg), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = my_red,
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient Temperature at Capture (°C)") + 
  ylab("Plasma Osmolality (mmol / kg)") + 
  annotate("text", x = 23, y = 320, 
           label = "paste(italic(R) ^ 2, \" = 0.29\")", 
           parse = TRUE,
           size = 6) +
  annotate("text", x = 23, y = 305, 
           label = "paste(italic(p), \" < 0.0001\")", 
           parse = TRUE,
           size = 6) +
  xlim(14, 24) +
  ylim(300,450) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
) -> osml_temp_fig
osml_temp_fig

# export figure
#ggsave(filename = "osml_temp_fig.jpeg",
 #      plot = osml_temp_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 6, height = 4)

# lm
lm_osml_temp <- lm(osmolality_mmol_kg ~ temp_C_interpol,
           data = morpho_blood_SMI)
summary(lm_osml_temp)
```

### Hct ~ Individual

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = individual_ID,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = individual_ID, 
                  y = hematocrit_percent, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Individual Lizard") + 
  ylab("Hematocrit (%)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)
```

### Osml ~ Individual

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = individual_ID,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = individual_ID, 
                  y = osmolality_mmol_kg, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Individual Lizard") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)
```



## Conclusion

Osmolality seems to be affected by:
- SMI (large effect, although not statistically significant)
- sex (NS)
- whether or not the sample was hemolyzed (*) !
- week/date of sampling!! (***)
- capture temp & humidity (both ***)

So, for the LMM to predict osmolality, we will start with SMI, hemolyzed/not, week/date, and capture temp and absolute humidity as our predictor variables in the model. 

Hematocrit was only meaningfully different based on sex, so that's the only statistic we'll include in the paper for what variables affect hematocrit.


## Osmolality Multi-Figure

```{r}
ggarrange(osml_temp_fig, osml_abhum_fig,
          ncol = 2, nrow = 1
          ) -> osml_multi_fig
osml_multi_fig
# export figure
#ggsave(filename = "osml_multi_fig.jpeg",
 #      plot = osml_multi_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 12, height = 4)
```




## What affects evaporative water loss?

Potential relationships:
- CEWL ~ date/week, 
        individual, 
        SVL, 
        SMI, 
        gravidity, 
        hct, 
        osml, 
        cloacal temp, 
        ambient temp, 
        ambient RH, 
        measurement temp,
        measurement RH,
        **body region**

### CEWL ~ Body Region

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = (region), 
                   y = TEWL_g_m2h, 
                   color = region
                   ), 
               size = 1,
               alpha = 1) +
  theme_classic() + 
  xlab("Body Region") + 
  ylab(bquote('CEWL (g / '*m^2~h*')')) + 
  annotate("text", x = 1, y = 64, label = "a", size = 6) +
  annotate("text", x = 2, y = 77, label = "b", size = 6) +
  annotate("text", x = 3, y = 95, label = "b", size = 6) +
  annotate("text", x = 4, y = 65, label = "a", size = 6) +
  annotate("text", x = 5, y = 106, label = "b", size = 6) +
  scale_color_brewer(palette = "Set2") +
  ylim(1, 110) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> CEWL_region_fig
CEWL_region_fig

# export figure
ggsave(filename = "CEWL_region_fig.jpeg",
       plot = CEWL_region_fig,
       path = "./final_figures",
       device = "jpeg",
       dpi = 1200,
       width = 6, height = 4)
```


```{r}
CEWL_lm1 <- lm(TEWL_g_m2h ~ region, data = CEWL_data_full)
summary(CEWL_lm1)
```

Also get pairwise statistics:

```{r}
# one-way ANOVA
CEWL_region_aov <- aov(data = CEWL_data_full,
                       TEWL_g_m2h ~ region)
# post-hoc pairwise analysis
TukeyHSD(CEWL_region_aov)
```


### CEWL Heat Map

get means:

```{r}
mean_CEWL_region <- CEWL_data_full %>%
  group_by(region) %>%
  summarise(CEWL = mean(TEWL_g_m2h)) %>%
  arrange(CEWL)
mean_CEWL_region
```

get colors:

```{r}
my_CEWL_colors <- RColorBrewer::brewer.pal(9, "Blues")[1:9]
```

assign colors:

```{r}
CEWL_heatmap_colors <- data.frame(region = c("Dorsum", 
                                             "Ventrum", 
                                             "Head",
                                             "Dewlap", 
                                             "Mite Patch"), 
                                  color = c(my_CEWL_colors[1], #dorsum
                                            my_CEWL_colors[2], #ventrum
                                            my_CEWL_colors[7], #head
                                            my_CEWL_colors[8], #dewlap
                                            my_CEWL_colors[9])) #mite patch

#write.csv(CEWL_heatmap_colors, "./CEWL_heatmap_colors.csv")
```



### CEWL ~ Osmolality

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = osmolality_mmol_kg,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = osmolality_mmol_kg, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Osmolality") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
CEWL_lm2 <- lm(TEWL_g_m2h ~ region + osmolality_mmol_kg,
           data = CEWL_data_full)
summary(CEWL_lm2)


# Facet ggplot
ggplot(aes(osmolality_mmol_kg, TEWL_g_m2h), data = CEWL_data_full) + 
  geom_point() + 
  stat_smooth(aes(x = osmolality_mmol_kg, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 )+
    theme_classic() + 
  xlab("Osmolality") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)+
  facet_wrap(~ region) # create a facet for each body region
```


### CEWL ~ Hematocrit

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = hematocrit_percent,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = hematocrit_percent, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Hematocrit") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
CEWL_lm3 <- lm(TEWL_g_m2h ~ region * hematocrit_percent,
           data = CEWL_data_full)
summary(CEWL_lm3)
```


### CEWL ~ Cloacal Temperature


```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = cloacal_temp_C,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = cloacal_temp_C, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1) + 
  theme_classic() + 
  xlab("Cloacal Temperature (°C)") + 
  ylab("") +
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(20, 28) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        plot.margin = unit(c(0.1,0.1,0.1,0), "cm"),
        legend.text.align = 0,
        legend.position = "none"
        #legend.position = c(0.9, 0.85)
  #) +
  #guides(color = guide_legend(nrow = 2, byrow = TRUE)
         ) -> CEWL_ctemp_fig
CEWL_ctemp_fig

# export figure
#ggsave(filename = "CEWL_ctemp_fig.tiff",
 #      plot = CEWL_ctemp_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)
```



```{r}
CEWL_lm4 <- lm(TEWL_g_m2h ~ region + cloacal_temp_C,
           data = CEWL_data_full)
summary(CEWL_lm4)
```



### CEWL ~ Capture Temperature

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = temp_C_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = temp_C_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  scale_color_brewer(palette = "Set2") +
  theme_classic() + 
  xlab("Ambient Temperature at Capture (°C)") + 
  #ylab("") +
  ylim(1, 100) +
  ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        plot.margin = unit(c(0.1,0.5,0.1,0.1), "cm"),
        legend.text.align = 0,
        legend.position = "none"
) -> cap_temp_CEWL
cap_temp_CEWL

# lm: CEWL ~ region + capture temp
CEWL_lm5 <- lm(TEWL_g_m2h ~ region * temp_C_interpol,
           data = CEWL_data_full)
summary(CEWL_lm5)
```


### CEWL ~ Capture Humidity

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_jitter(aes(x = abs_humidity_g_m3_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = abs_humidity_g_m3_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab(bquote('Absolute Humidity at Capture (g/'*m^3*')')) + 
  ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(8.9, 11.5) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        legend.text.align = 0,
        plot.margin = unit(c(0.1,0.5,0.1,0.1), "cm"),
        legend.position = "none"
        #legend.position = c(0.15, 0.85)
         ) -> CEWL_abshum_fig
CEWL_abshum_fig

# export figure
#ggsave(filename = "CEWL_abshum_fig.tiff",
 #      plot = CEWL_abshum_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)
```


```{r}
CEWL_lm6 <- lm(TEWL_g_m2h ~ region * abs_humidity_g_m3_interpol,
           data = CEWL_data_full)
summary(CEWL_lm6)
```



### CEWL ~ Wind Speed

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = Wind_mph_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = Wind_mph_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Average Windspeed During Measurement") + 
  ylab("CEWL") + 
  ylim(1, 100) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm: CEWL ~ region + aquaflux measurement RH
CEWL_lm7 <- lm(TEWL_g_m2h ~ region + Wind_mph_interpol,
           data = CEWL_data_full)
summary(CEWL_lm7)
```

### CEWL ~ Solar Rad

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = Solar_rad_Wm2_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = Solar_rad_Wm2_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  scale_color_brewer(palette = "Set2") +
  xlab(bquote('Solar Radiation at Capture (W/'*m^2*')')) + 
  ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  #ylab("") +
  ylim(0,100) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        plot.margin = unit(c(0.1,0.5,0.1,0.1), "cm"),
        legend.text.align = 0,
        legend.position = "none"
) -> sorad_CEWL_plot
sorad_CEWL_plot

# lm: CEWL ~ region + aquaflux measurement RH
CEWL_lm8 <- lm(TEWL_g_m2h ~ region + Solar_rad_Wm2_interpol,
           data = CEWL_data_full)
summary(CEWL_lm8)
```



### CEWL ~ Measurement Temperature

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = ambient_temp_C,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = ambient_temp_C, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  scale_color_brewer(palette = "Set2") +
  xlab("Ambient Temperature During Measurement") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        legend.text.align = 0,
        legend.position = "none"
)

# lm: CEWL ~ region + aquaflux measurement temp
CEWL_lm9 <- lm(TEWL_g_m2h ~ region * ambient_temp_C,
           data = CEWL_data_full)
summary(CEWL_lm9)
```


### CEWL ~ Measurement Humidity

Very interesting relationship! Mite patch CEWL decreases as ambient humidity increases, but every other location appears to increase. In this case, an interaction term is warranted.

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = ambient_RH_percent,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = ambient_RH_percent, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient Relative Humidity During Measurement") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm: CEWL ~ region + aquaflux measurement RH
CEWL_lm10 <- lm(TEWL_g_m2h ~ region * ambient_RH_percent,
           data = CEWL_data_full)
summary(CEWL_lm10)
```

### CEWL ~ Individual

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = individual_ID,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = individual_ID, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Individual Lizard") + 
  ylab("CEWL") + 
  
  # just to get a better look
  # ylim(5, 40) +
  
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
CEWL_lm11 <- lm(TEWL_g_m2h ~ region + individual_ID,
           data = CEWL_data_full)
summary(CEWL_lm11)
```

### CEWL ~ SVL

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

# lm
CEWL_lm12 <- lm(TEWL_g_m2h ~ region + SVL_mm,
           data = CEWL_data_full)
summary(CEWL_lm12)
```

### CEWL ~ SMI

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SMI,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = SMI, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Scaled Mass Index (g)") + 
  ylab(bquote('CEWL (g / '*m^2~h*')')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(2, 16) +
  scale_x_continuous(breaks = c(seq(2, 16, by = 2))) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        plot.margin = unit(c(0.1,0.5,0.1,0.1), "cm"),
        legend.text.align = 0,
        legend.position = c(0.15, 0.85)
         ) -> CEWL_SMI_fig
CEWL_SMI_fig

# export figure
#ggsave(filename = "CEWL_mass_fig.tiff",
 #      plot = CEWL_mass_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)


# lm
CEWL_lm13 <- lm(TEWL_g_m2h ~ region + SMI,
           data = CEWL_data_full)
summary(CEWL_lm13)
```

### CEWL ~ Mass

Head has an opposite trend from all the other body regions, so we need an interaction term.

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = mass_g,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = mass_g, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Mass (g)") + 
  ylab("") +
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(2, 16) +
  scale_x_continuous(breaks = c(seq(2, 16, by = 2))) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 18),
        plot.margin = unit(c(0.1,0.1,0.1,0), "cm"),
        legend.text.align = 0,
        legend.position = "none"
        #legend.position = c(0.5, 0.5)
         ) -> CEWL_mass_fig
CEWL_mass_fig

# MUST CHANGE COMMENTS ABOVE to produce this
CEWL_legend <- as_ggplot(get_legend(CEWL_mass_fig))

# export figure
#ggsave(filename = "CEWL_mass_fig.tiff",
 #      plot = CEWL_mass_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)


# lm
CEWL_lm13.1 <- lm(TEWL_g_m2h ~ region*mass_g,
           data = CEWL_data_full)
summary(CEWL_lm13.1)
```

### CEWL ~ Sex

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = sex_M_F, 
                   y = TEWL_g_m2h, 
                   color = sex_M_F
                   ), 
               size = 1,
               alpha = 0.6) + 
  facet_wrap(~region) +
  scale_color_manual(values = c("royalblue1", "mediumorchid")) +
  scale_x_discrete(breaks = c(1,2,3)) +
  theme_classic() + 
  xlab("Sex") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
CEWL_lm14 <- lm(TEWL_g_m2h ~ region + sex_M_F, 
           data = CEWL_data_full)
summary(CEWL_lm14)
```

### CEWL ~ Gravidity

```{r}
CEWL_data_full %>% 
  dplyr::filter(sex_M_F == "F") %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = gravid_Y_N, 
                   y = TEWL_g_m2h, 
                   color = gravid_Y_N
                   ), 
               size = 1,
               alpha = 0.6) + 
  facet_wrap(~region) +
  scale_color_manual(values = c("royalblue1", "mediumorchid")) +
  scale_x_discrete(breaks = c(1,2,3)) +
  theme_classic() + 
  xlab("Female Gravid or Not") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
CEWL_lm15 <- lm(TEWL_g_m2h ~ region + gravid_Y_N, 
           data = CEWL_data_full)
summary(CEWL_lm15)
```


### CEWL ~ Week

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = TEWL_g_m2h, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  facet_wrap(~region) + # could not figure out how to change facet labels without changing underlying data
  scale_color_manual(values = c("royalblue1", "mediumorchid", "seagreen4",
                                "royalblue1", "mediumorchid", "seagreen4")) +
  scale_x_discrete(breaks = c(1,2,3)) +
  theme_classic() + 
  xlab("Date") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)

# lm
CEWL_lm16 <- lm(TEWL_g_m2h ~ region + date,
           data = CEWL_data_full)
summary(CEWL_lm16)
```


### CEWL ~ holding time

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = hold_time,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = hold_time, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Holding Time (minutes)") + 
  ylab("CEWL (g/m^2/hr)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0,
)

CEWL_lm17 <- glm(data = CEWL_data_full, 
                      TEWL_g_m2h ~ hold_time + region)
summary(CEWL_lm17)
```



## Conclusion

The following variables should be included in the full LMM:
- *body region* 
- *cloacal temperature* at measurement
- *capture temp* (and try an interaction with region)
- capture *wind speed* and *solar radiation*
- *absolute humidity* (and try an interaction with region)
- measurement temperature (and try an interaction with region)
- individual_ID (as a random effect)
- *SVL* and *mass*
- *hold time*

## CEWL Multi-Figure

```{r}
ggarrange(cap_temp_CEWL, CEWL_ctemp_fig, 
          sorad_CEWL_plot, CEWL_mass_fig, 
          CEWL_abshum_fig, 
          CEWL_legend, # doesn't actually work
          ncol = 2, nrow = 3
          ) -> CEWL_multi_fig
CEWL_multi_fig
# export figure
#ggsave(filename = "CEWL_multi_fig.jpeg",
 #      plot = CEWL_multi_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 12, height = 12)
```



# LMMs

## Hydration

Based on the simple linear models and figures above, osmolality should be predicted by sample eye, hemolysis, date/week, individual, capture temperature, and capture absolute humidity.

Prep dataframe for computing models:

```{r}
hydrat_mod_dat <- morpho_blood_SMI %>%
  dplyr::select(date, 
                individual_ID,
                osmolality_mmol_kg,
                temp_C_interpol,
                abs_humidity_g_m3_interpol,
                SMI,
                hemolyzed
                ) %>%
  dplyr::filter(complete.cases(.))
summary(hydrat_mod_dat)
```


### Multicollinearity

First, check for multicollinearity among independent variables:

```{r}
pairs(hydrat_mod_dat)

# also make another plot with r-sq values
# only continuous numeric variables work for this one
hydrat_mod_dat %>% 
  # select cont variables 
  dplyr::select(temp_C_interpol,
                abs_humidity_g_m3_interpol) %>% 
  # multicollinearity plot
  chart.Correlation(., histogram = F, pch = 19)
```

Date and individual_ID are collinear and should not both be used as fixed effects. But, individual_ID is a factor and there is not repetition in the dataset, so that's not feasible as a variable. Temperature and absolute humidity are the only continuous variables, and they are not badly collinear.


### Models & Selection
                
Start with all the variables that were significant individually in SLRs. 

```{r, hydration model 1}
# model 1
hydrat_mod1 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                            # start with interaction + singular effect
                           abs_humidity_g_m3_interpol*temp_C_interpol +
                            # other potentially important factor
                            SMI +
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod1)
drop1(hydrat_mod1)
```

The model would improve (based on lower AIC) if we drop SMI as a predictor.

```{r, hydration model 2}
# model 2
hydrat_mod2 <- lmerTest::lmer(data = hydrat_mod_dat,
                          osmolality_mmol_kg ~ 
                           abs_humidity_g_m3_interpol*temp_C_interpol +
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod2)

# compare to full model
anova(hydrat_mod1, hydrat_mod2)
```

We do not decrease our predictive power significantly by dropping SMI, so we will consider the reduced model (2) to be better than the full (1).

Check whether to continue dropping terms:

```{r}
drop1(hydrat_mod2)
```

Dropping the current predictors will not improve AIC any more than its current value, so hydrat_mod2 is the best model to predict osmolality.


### Best Model

```{r}
# save model 2 summary object
osml_best_mod <- broom.mixed::tidy(hydrat_mod2)
# export 
write.csv(osml_best_mod, "./best models/osml_best_mod_vals.csv")
```


### Check LM Assumptions (Hydration Model)

First, get residuals:

```{r}
res_hydrat_mod <- hydrat_mod_dat %>%
  mutate(y_hat = predict(hydrat_mod2),
         e = residuals(hydrat_mod2))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = res_hydrat_mod, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("Hydration Model 5") +
  geom_hline(yintercept = 0)
```

It looks pretty evenly distributed. No clear patterning, so linearity and equal error variance should be satisfied.

Brown-Forsythe test to statistically check equal variance:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)

```{r}
# need to create the right data & format first
bf_data_temp <- res_hydrat_mod %>%
  dplyr::filter(complete.cases(temp_C_interpol)) %>%
  dplyr::mutate(middle = median(temp_C_interpol),
                side = temp_C_interpol > middle)
bf_data_temp$side <- as.factor(bf_data_temp$side)

# now run test
bf.test(formula = e ~ side, # y~x
        data = bf_data_temp, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )

# need to create the right data & format first
bf_data_abshum <- res_hydrat_mod %>%
  dplyr::filter(complete.cases(abs_humidity_g_m3_interpol)) %>%
  dplyr::mutate(middle = median(abs_humidity_g_m3_interpol),
                side = abs_humidity_g_m3_interpol > middle)
bf_data_abshum$side <- as.factor(bf_data_abshum$side)

# now run test
bf.test(formula = e ~ side, # y~x
        data = bf_data_abshum, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is satisfied.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(res_hydrat_mod$e)
shapiro.test(res_hydrat_mod$e)
```

Normality is satisfied.


### Conclusion

hydrat_mod2 is the best model to predict osmolality, and the model satisfies all linear regression assumptions.



## CEWL

Based on the simple linear models and figures above, CEWL should be predicted by:
- body region
- cloacal temperature at measurement
- capture temperature, absolute humidity, wind speed, and solar radiation
- ambient temperature during measurement
- SVL and mass
- hold time (time between capture vs measurement)
- individual ID (as a random effect)

Prep dataframe for models:

```{r}
CEWL_mod_dat <- CEWL_data_full %>% 
  # select variables of interest
  dplyr::select(date,
                hold_time,
                individual_ID,
                mass_g,
                SVL_mm, 
                TEWL_g_m2h,
                region,
                cloacal_temp_C,
                temp_C_interpol,
                abs_humidity_g_m3_interpol,
                Wind_mph_interpol,
                Solar_rad_Wm2_interpol,
                ambient_temp_C
                ) %>%
  dplyr::filter(complete.cases(.)) # removes 69 observations
```


### Multicollinearity

Check for multicollinearity among independent variables:

```{r}
CEWL_mod_dat %>% 
  # get rid of dependent variable
  dplyr::select(-TEWL_g_m2h, individual_ID) %>%
  # multicollinearity plot
  pairs(.)

# also make another plot with r-sq values
# non-numeric variables don't work for this
CEWL_mod_dat %>% 
  # select variables of interest
  dplyr::select(-TEWL_g_m2h, -date, -region, -individual_ID) %>% 
  # multicollinearity plot
  chart.Correlation(., histogram = F, pch = 19)
```

Mass and SVL are very collinear variables that should not be used in combination. Cloacal temp and hold time are pretty collinear, which makes sense; as we held them, they got cooler because they were inside and not basking. Individual ID and absolute humidity are also pretty collinear, but it's less intuitive. Temperature and solar radiation, as well as humidity and solar radiation, are each collinear pairs. We will use model selection to figure out which variable from each collinear pair is better to include in the model.



### Models & Selection

This is the full model with every potential variable and interaction baed on figures and SLR.

```{r}
# model 1
CEWL_mod1 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g + ambient_temp_C +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         hold_time + SVL_mm +
                         cloacal_temp_C +
                         temp_C_interpol:abs_humidity_g_m3_interpol +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod1)
```


Check which variables to drop:

```{r}
drop1(CEWL_mod1)
```

Based on AIC, dropping SVL, hold time, temp, humidity, wind speed, region:ambient_temp_C, and temp_C_interpol:abs_humidity_g_m3_interpol would result in a better model. 

Start with region:ambient_temp_C and temp_C_interpol:abs_humidity_g_m3_interpol interactions:

```{r}
# model 2
CEWL_mod2 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         hold_time + SVL_mm +
                         cloacal_temp_C +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod2)

# compare
anova(CEWL_mod2, CEWL_mod1)
```

AIC improved somewhat and we do not lose a significant amount of predictive power, so the reduced model is better. Continue dropping...

Check drop terms again:

```{r}
drop1(CEWL_mod2)
```

Hold time, SVL, and wind should still be deleted.

```{r}
# model 3
CEWL_mod3 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         cloacal_temp_C +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod3)

# compare
anova(CEWL_mod3, CEWL_mod1)
anova(CEWL_mod3, CEWL_mod2)
```

Once again, the AIC is slightly lower, and our model fit is not significantly worse by going to model 3, so the reduced model is better.

Check drop terms again to make sure nothing else could potentially be removed:

```{r}
drop1(CEWL_mod3)
```

Check whether removing Solar_rad_Wm2_interpol is okay:

```{r}
# model 4
CEWL_mod4 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         cloacal_temp_C +
                         (1|individual_ID)) 
summary(CEWL_mod4)

# compare
anova(CEWL_mod4, CEWL_mod1)
anova(CEWL_mod4, CEWL_mod3)
```

We do lose significant predictive power when we go from model 3 to 4... So model 3 is the best model to predict CEWL.

Since we dropped a lot of variables, I want to go back and make sure to use as much data as possible in the final model, so I can add back in observations with missing values for variables no longer included in the reduced model.

```{r}
# filter
CEWL_mod_dat2 <- CEWL_data_full %>% 
  # select variables of interest
  dplyr::select(individual_ID,
                mass_g,
                TEWL_g_m2h,
                region,
                cloacal_temp_C,
                temp_C_interpol,
                abs_humidity_g_m3_interpol,
                Solar_rad_Wm2_interpol,
                ) %>%
  dplyr::filter(complete.cases(.)) # able to have 5 more observations

# redo best model



# model 3
CEWL_mod3_adj <- lmerTest::lmer(data = CEWL_mod_dat2,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                         cloacal_temp_C +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod3_adj)
```



### Best Model

The best model is CEWL predicted by: body region and its interaction with mass and capture temp and humidity, cloacal temperature, solar radiation at capture time, and individual ID as a random effect.

```{r}
# save best model info
CEWL_best_mod <- broom.mixed::tidy(CEWL_mod3_adj)
# export 
#write.csv(CEWL_best_mod, "./best models/CEWL_best_mod_vals.csv")
```



### Check LM Assumptions

First, get residuals:

```{r}
CEWL_mod_res <- CEWL_mod_dat2 %>%
  mutate(y_hat = predict(CEWL_mod3_adj),
         e = residuals(CEWL_mod3_adj))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = CEWL_mod_res, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("CEWL Model Residuals") +
  geom_hline(yintercept = 0)
```

It's definitely making a fan shape. :(

Brown-Forsythe test to statistically check equal variance, for each continuous predictor variable:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)


```{r}
# need to create the right data & format first
bf_data_CEWL <- CEWL_mod_res %>%
  dplyr::mutate(middle_mass = median(mass_g), # mass
                side_mass = as.factor(mass_g > middle_mass),
                # solar radiation
                middle_sorad = median(Solar_rad_Wm2_interpol),
                side_sorad = as.factor(Solar_rad_Wm2_interpol > middle_sorad), 
                # temperature
                middle_temp = median(temp_C_interpol),
                side_temp = as.factor(temp_C_interpol > middle_temp),
                # absolute humidity
                middle_absh = median(abs_humidity_g_m3_interpol),
                side_absh = as.factor(abs_humidity_g_m3_interpol > middle_absh),
                middle_ct = median(cloacal_temp_C),
                side_ct = as.factor(cloacal_temp_C > middle_ct)
                )


# now run test
bf.test(formula = e ~ side_absh, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_temp, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_sorad, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_ct, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_mass, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is satisfied for all 5 continuous predictor variables.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(CEWL_mod_res$e)
shapiro.test(CEWL_mod_res$e)
```

not normal!


### Test Transformations 

Can I improve satisfaction of LM assumptions by transforming the dependent variable?

```{r}
# sqrt(TEWL)
CEWL_data_full %>%
  ggplot(., aes(x = sqrt(TEWL_g_m2h))) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("sqrt(CEWL)") + 
  ylab("Count") + 
  facet_wrap(~region)

# log(temperature)
CEWL_data_full %>%
  ggplot(., aes(x = log(TEWL_g_m2h))) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("LOG(CEWL)") + 
  ylab("Count") + 
  facet_wrap(~region)
```


Log transforming seems to be pretty effective across body regions.



### Transform & Re-Model

I will log-transform CEWL and see whether it makes the models satisfy LMM assumptions better.

Run CEWL model 4 with log-transformed CEWL:

```{r}
summary(CEWL_mod_dat2)
# log-transformed model 3
CEWL_mod3_t <- lmerTest::lmer(data = CEWL_mod_dat2,
                          log(TEWL_g_m2h) ~
                            region * (mass_g +
                                     temp_C_interpol +
                                     abs_humidity_g_m3_interpol) +
                            cloacal_temp_C + Solar_rad_Wm2_interpol +
                            (1|individual_ID)) 
summary(CEWL_mod3_t)

# compare
anova(CEWL_mod3_t, CEWL_mod3_adj)
```



### Re-Check Assumptions (transformed model 3)

First, get residuals:

```{r}
CEWL_t_mod_res <- CEWL_mod_dat2 %>%
  mutate(y_hat = predict(CEWL_mod3_t),
         e = residuals(CEWL_mod3_t))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = CEWL_t_mod_res, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("CEWL Model 13 Residuals") +
  geom_hline(yintercept = 0)
```

It looks much much better. :) Equal error variance doesn't look perfect, but there's no more fan shape.

Brown-Forsythe test to statistically check equal variance:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)

```{r}
# need to create the right data & format first
bf_data_CEWL_t <- CEWL_t_mod_res %>%
  dplyr::mutate(middle_mass = median(mass_g), # mass
                side_mass = as.factor(mass_g > middle_mass),
                # solar radiation
                middle_sorad = median(Solar_rad_Wm2_interpol),
                side_sorad = as.factor(Solar_rad_Wm2_interpol > middle_sorad), 
                # temperature
                middle_temp = median(temp_C_interpol),
                side_temp = as.factor(temp_C_interpol > middle_temp),
                # absolute humidity
                middle_absh = median(abs_humidity_g_m3_interpol),
                side_absh = as.factor(abs_humidity_g_m3_interpol > middle_absh),
                middle_ct = median(cloacal_temp_C),
                side_ct = as.factor(cloacal_temp_C > middle_ct)
                )


# now run test
bf.test(formula = e ~ side_absh, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_temp, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_sorad, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_ct, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_mass, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is still satisfied for all continuous predictor variables.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(CEWL_t_mod_res$e)
shapiro.test(CEWL_t_mod_res$e)
```

Still not statistically normal... but the distribution looks a lot better.


### Conclusion

The best CEWL model should use log-transformed CEWL because this greatly improves the model based on AIC and it allows the model to satisfy the linearity assumption of LMM. 

```{r}
# save log model 3 summary object
CEWL_best_t_mod <- broom.mixed::tidy(CEWL_mod3_t)
# export 
write.csv(CEWL_best_t_mod, "./best models/CEWL_best_mod_t_vals.csv")
```





# What to Present in the Paper

- figures (exported)
- hct SLR
- best osml mod (transformed?)
- best CEWL mod (CEWL transformed)


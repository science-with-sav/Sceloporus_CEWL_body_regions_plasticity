---
title: "Cal Poly Herpetology CURE - Capture Data Analyses"
author: "Savannah Weaver"
date: "June 2021"
output: 
  pdf_document:
    toc: TRUE
---


# Packages

```{r setup, include=FALSE}
if (!require("tidyverse")) install.packages("tidyverse")
library("tidyverse") # workflow and plots
if (!require("zoo")) install.packages("zoo")
library("zoo") # interpolation using na.approx
if (!require("weathermetrics")) install.packages("weathermetrics")
library("weathermetrics") # F to C conversion
if (!require("PerformanceAnalytics")) install.packages("PerformanceAnalytics") 
library("PerformanceAnalytics") # pretty multicollinearity plots
if (!require("AICcmodavg")) install.packages("AICcmodavg")
library("AICcmodavg") # VIF calculations
if (!require("UsingR")) install.packages("UsingR")
library("UsingR")
if (!require("lme4")) install.packages("lme4")
library("lme4") # for LMMs
if (!require("lmerTest")) install.packages("lmerTest")
library("lmerTest") # for p-values
if (!require("onewaytests")) install.packages("onewaytests")
library("onewaytests") # for Brown-Forsythe test
if (!require("ggpubr")) install.packages("ggpubr")
library("ggpubr") # for ggplot multi-figures
if (!require("broom")) install.packages("broom")
library("broom") # lmer model export
```


# Background and Goals

This data was collected April - May 2021 during a course-based undergraduate research experience (CURE) in Dr. Emily Taylor's Herpetology class of Spring Quarter 2021 at Cal Poly, San Luis Obispo. This part of the study was conducted to describe the variation of osmoregulation (cutaneous evaporative water loss) and osmotic balance (plasma osmolality and hematocrit) in *Sceloporus occidentalis* and to investigate what drives that variation. Please refer to **doi:** for full details.


# Data

### Morphometrics and Blood Data

This data was collected upon capture of each lizard.

Variables in this dataframe:
- date
- collection/capture time for each lizard
- individual ID for each lizard
- sock ID used to capture each lizard (removed, not relevant to analyses)
- SVL = snout-vent length
- mass in grams
- sex
- if female, whether or not gravid (with eggs)
- which eye the blood sample was taken from
- percent hematocrit = percent of blood that's red blood cells
- osmolality = the concentration of solutes in the blood (this is the average of 1-3 replicates)
- cloacal temperature at the time of CEWL measurement
- processing time for each lizard, when all measurements were finished
- hemolyzed = whether or not red blood cells burst and contaminated plasma

Before loading in this data, some incorrectly-measured hematocrit and osmolality were omitted:
- hematocrit for individuals 1-16, due to observer error
- osmolality for individual 19, due to instrumental error

```{r morpho blood data}
# load and format data
morpho_blood_dat <- read.csv("./data/Herpetology_Data.csv", # filename
                             na.strings=c("","NA") # fix empty cells
                             ) %>%
  dplyr::mutate(# put date and time together
                collect_date_time = (paste(date, collect_time)), 
                # replace some date-time values that have missing times
                collect_date_time = replace(collect_date_time, 
                                            collect_date_time == "4/5/21 NA", NA),
                # correctly format date-time variable
                collect_date_time = as.POSIXct(collect_date_time, 
                                               format = "%m/%d/%y %H:%M"),
                # correctly format date-only variable
                date = as.Date(date, format = "%m/%d/%y"),
                # correctly format collection time variable
                # format extracts just time after posix adds arbitrary date
                collect_time = (as.POSIXct(collect_time, format = "%H:%M")),
                # correctly format processing time variable
                processing_time = (as.POSIXct(processing_time, format = "%H:%M")),
                # set individual_ID variable as a factor, not numeric
                individual_ID = as.factor(individual_ID),
                # set sex variable as a factor, not character
                sex_M_F = as.factor(sex_M_F),
                # set gravidity variable as a factor, not character
                gravid_Y_N = as.factor(gravid_Y_N),
                # set blood sample eye variable as a factor, not character
                blood_sample_eye = as.factor(blood_sample_eye),
                # set hemolyzed variable as a factor, not character
                hemolyzed = as.factor(hemolyzed),
                # compute holding time as capture time - cloacal measurement time:
                hold_time = as.numeric(processing_time - collect_time)
                ) %>%
  # remove two columns not relevant for statistics
  dplyr::select(-sock_ID, -notes)

# check
summary(morpho_blood_dat)
unique(morpho_blood_dat$date)

# get info
morpho_blood_dat %>%
  dplyr::filter(complete.cases(hold_time)) %>%
  summarise(mean_hold_time_minutes = mean(hold_time),
            mean_hold_time_hrs = mean_hold_time_minutes/60)

# export
#write.csv(morpho_blood_dat, "exported_data/capture_hydration.csv")
```

I want to test if any IDs are missing, and which ones if so.

```{r}
test <- c(seq(1, 150, by = 1))
lost <- test[test %nin% morpho_blood_dat$individual_ID]
lost
```

Individuals 23 and 56 actually both do not exist because those numbers were skipped when assigning IDs, so we have all the individuals measured in the dataframe.




### CEWL Data

First, load it all in and merge.

Variables in this dataframe are:
- date
- time
- date_time combined variable
- individual_ID for each lizard measured
- region = where on the body CEWL was measured
- TEWL_g_m2h = CEWL measurement value in grams/sq-meter/hour
- ambient_temp_C = temperature when and where measurement was taken
- ambient_RH_percent = relative humidity when and where measurement was taken
- e_s_kPa = saturation vapor pressure at a given temperature (calculated using the Clausius-Clapeyron equation from Riddell et al. 2017, cited in the published paper using this data)
- e_a_kPa = actual ambient vapor pressure (e_a = e_s * RH proportion)
- VPD_kPa = vapor pressure deficit, which is essentially the drying power of the air (VPD = e_s - e_a)

```{r CEWL data}
# week 1
CEWL_April_05 <- read.csv("./data/capture_CEWL/4-5-21-CEWL.csv", # filename
                          na.strings=c("","NA")) %>% # fix empty cells
  # rename and select the pertinent variables/cols
  # I have to do this for each one 
  # so they all have the same number of columns for joining
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 2
CEWL_April_19 <- read.csv("./data/capture_CEWL/4-19-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 3
CEWL_April_26 <- read.csv("./data/capture_CEWL/4-26-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 4
CEWL_May_3 <- read.csv("./data/capture_CEWL/5-3-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 5
CEWL_May_10 <- read.csv("./data/capture_CEWL/5-10-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# week 6
CEWL_May_17 <- read.csv("./data/capture_CEWL/5-17-21-CEWL.csv",
                          na.strings=c("","NA")) %>%
  dplyr::select(date = Date, 
                Time, Status,
                ID = Comments,
                TEWL_g_m2h = TEWL..g..m2h.., # rename
                ambient_temp_C = AmbT..C., # rename
                ambient_RH_percent = AmbRH....
                )

# merge all CEWL datafiles & reformat
CEWL <- CEWL_April_05 %>% # week 1
  # join with weeks 2-6
  rbind(., CEWL_April_19, 
        CEWL_April_26,
        CEWL_May_3,
        CEWL_May_10,
        CEWL_May_17
        ) %>%
  # remove any unsuccessful measurements
  dplyr::filter(Status == "Normal") %>%
  # extract individual_ID and region separately from the "ID" variable
  separate(ID, c("individual_ID", "region")) %>%
  # reformat data
  dplyr::mutate(# paste and format date-time variable
                CEWL_date_time = as.POSIXct(paste(date, Time), 
                                            format = "%m/%d/%y %I:%M:%S %p"),
                # reformat date only
                date = as.Date(date, format = "%m/%d/%y"),
                # reformat time 
                # format extracts just time after posix adds arbitrary date
                # but then it's a character again... 
                Time = format(as.POSIXct(Time, format = "%I:%M:%S %p"), 
                              format = "%H:%M:%S"),
                # format individual ID as a factor
                individual_ID = as.factor(individual_ID),
                # set body region as a factor variable after getting only the consistent characters due to typos
                region = as.factor(substring(region, 1, 4)),
                # calculate VPD
                ambient_temp_K = ambient_temp_C + 273.15,
                e_s_kPa = 0.611*exp((2500000/461.5)*
                                  ((1/273)-(1/ambient_temp_K))),
                e_a_kPa = e_s_kPa * (ambient_RH_percent/100),
                VPD_kPa = e_s_kPa - e_a_kPa
                ) %>%
  # remove cols not relevant to stats
  dplyr::select(-Status) %>%
  # remove any rows with missing values
  dplyr::filter(complete.cases(.))
summary(CEWL)
```


Write CEWL dataframe as a csv for use in other analyses:

```{r}
#write.csv(CEWL, "exported_data/capture_CEWL.csv")
```




### Weather Data

This data was obtained from http://www.itrc.org/databases/precip/ (Adcon Server Data) to test the effect of ambient conditions on CEWL. This is different from the ambient conditions already measured with CEWL, which are the temperature and humidity around the measurement device at the time of measurement. We think that the temperature, humidity, wind speed, and solar radiation the lizard was exposed to prior to capture may also affect CEWL.

We didn't have a daylight savings time switchover during this study, so we don't need to worry about incorporating. 

```{r}
# load in csvs and put all in one dataframe
weather <- read.csv("./data/weather/4_5Weather.csv", sep = ';') %>%
  rbind(read.csv("./data/weather/4_19Weather.csv", sep = ';')) %>%
  rbind(read.csv("./data/weather/5_3Weather.csv", sep = ';')) %>%
  rbind(read.csv("./data/weather/5_10Weather.csv", sep = ';')) %>%
  rbind(read.csv("./data/weather/5_17Weather.csv", sep = ';')) %>%
  # add a variable for combined date-time
  mutate(collect_date_time = as.POSIXct(paste(Date, Time),
                                format = "%m/%d/%y %I:%M:%S %p")) %>%
  # remove lonely date and time
  dplyr::select(-Date, -Time)
```

The weather data is only every 15 minutes, but I want to match it to any minute measurement, so I need to interpolate the values for each minute.

First, make a separate dataframe with every minute for each of those days.

```{r}
all_times <- data.frame(collect_date_time = c(# April 5
                           seq(from = as.POSIXct("2021-04-05 10:00"),
                               to = as.POSIXct("2021-04-05 16:00"),
                               by="min"),
                           # April 19
                           seq(from = as.POSIXct("2021-04-19 10:00"),
                               to = as.POSIXct("2021-04-19 16:00"),
                               by="min"),
                           # April 26
                           seq(from = as.POSIXct("2021-04-26 10:00"),
                               to = as.POSIXct("2021-04-26 16:00"),
                               by="min"),
                           # May 3
                           seq(from = as.POSIXct("2021-05-03 10:00"),
                               to = as.POSIXct("2021-05-03 16:00"),
                               by="min"),
                           # May 10
                           seq(from = as.POSIXct("2021-05-10 10:00"),
                               to = as.POSIXct("2021-05-10 16:00"),
                               by="min"),
                           # May 17
                           seq(from = as.POSIXct("2021-05-17 10:00"),
                               to = as.POSIXct("2021-05-17 16:00"),
                               by="min")
                           ))

```

Next, merge the weather data into the times dataframe and interpolate the temperature and humidity between measurements.

```{r}
all_times_weather <- all_times %>% # time only dataframe
  # add weather measurements based on matching date-time
  left_join(weather, by = 'collect_date_time') %>%
  # convert temperature units, thanks America
  mutate(temp_C = fahrenheit.to.celsius(Temperature_F, round = 2),
         # interpolate temperatures
         temp_C_interpol = na.approx(temp_C),
         # interpolate humidities
         RH_percent_interpol = na.approx(RH_percent),
         # interpolate Wind Speeds
         Wind_mph_interpol = na.approx(Wind_Speed_mph),
         # interpolate solar radiation
         Solar_rad_Wm2_interpol = na.approx(Pyranometer_W_m),
         # compute  VPD
         temp_K_interpol = temp_C_interpol + 273.15,
         e_s_kPa_int = 0.611*exp((2500000/461.5)*
                                  ((1/273)-(1/temp_K_interpol))),
         e_a_kPa_int = e_s_kPa_int * (RH_percent_interpol/100),
         VPD_kPa_int = e_s_kPa_int - e_a_kPa_int
         ) %>%
  # keep only the relevant variables
  dplyr::select(collect_date_time, 
                temp_C_interpol, 
                RH_percent_interpol, 
                VPD_kPa_int,
                Wind_mph_interpol, 
                Solar_rad_Wm2_interpol)
summary(all_times_weather)
```



## Compute Scaled Mass Index

This is also known as the body condition index, or log-log residuals.

I calculate as described by: Peig, J., & Green, A. J. (2009). New perspectives for estimating body condition from mass/length data: The scaled mass index as an alternative method. Oikos, 118(12), 1883–1891. https://doi.org/10.1111/j.1600-0706.2009.17643.x

### Step 1: mass ~ SVL

plot:

```{r}
morpho_blood_dat %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = mass_g, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = mass_g, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("Mass") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0
)
```

create a simple linear regression 

```{r}
mass_SVL_SLR <- lm(data = morpho_blood_dat, mass_g ~ SVL_mm)
summary(mass_SVL_SLR)
```

look for outliers by calculating residuals

```{r}
mass_SVL_SLR_residuals <- morpho_blood_dat %>%
  mutate(y_hat = 0.40988*SVL_mm - 16.04514,
         e = y_hat - mass_g)
```

plot residuals

```{r}
ggplot(data = mass_SVL_SLR_residuals, 
       aes(x = e)) +
  geom_histogram() + 
  theme_classic() + 
  xlab("residuals (e)") +
  geom_vline(xintercept = -3, linetype = "dashed", color = "maroon") +
  geom_vline(xintercept = 3, linetype = "dashed", color = "maroon")
ggplot(data = mass_SVL_SLR_residuals, 
       aes(x = e)) +
  geom_boxplot() + 
  theme_classic() + 
  scale_x_continuous(breaks = c(seq(-5, 5, 1))) +
  xlab("residuals (e)") +
  geom_vline(xintercept = -3, linetype = "dashed", color = "maroon") +
  geom_vline(xintercept = 3, linetype = "dashed", color = "maroon")
```

From the histogram, there are clearly points disconnected from the main curve. In the boxplot, we can distinguish that those outlying points have residuals <-3.5 and >3, so I'll go back and filter those out in the code chunk before making the distribution plots. Now the boxplot has no dots outside the main distribution.


calculating residuals with outliers excluded

```{r}
mass_SVL_SLR_residuals2 <- morpho_blood_dat %>%
  mutate(y_hat = 0.40988*SVL_mm - 16.04514,
         e = y_hat - mass_g) %>%
  dplyr::filter(e < 3 & e > -3)
```

plot new residuals

```{r}
ggplot(data = mass_SVL_SLR_residuals2, 
       aes(x = e)) +
  geom_histogram() + 
  theme_classic() + 
  xlab("residuals (e)") +
  geom_vline(xintercept = -3, linetype = "dashed", color = "maroon") +
  geom_vline(xintercept = 3, linetype = "dashed", color = "maroon")
ggplot(data = mass_SVL_SLR_residuals2, 
       aes(x = e)) +
  geom_boxplot() + 
  theme_classic() + 
  scale_x_continuous(breaks = c(seq(-5, 5, 1))) +
  xlab("residuals (e)") +
  geom_vline(xintercept = -3, linetype = "dashed", color = "maroon") +
  geom_vline(xintercept = 3, linetype = "dashed", color = "maroon")
```


And, check mean residual value:

```{r}
mass_SVL_SLR_residuals2 %>%
  summarise(mean_res = mean(e),
            med = median(e))
```

Not zero, which is not ideal, but pretty close. 

Next, check for high leverage points:

```{r}
# compute values for observations 
high_leverage <- data.frame(H = hatvalues(mass_SVL_SLR)
                            ) %>% mutate(row = rownames(.))

# compute cutoff value 
h_bar <- (3*sum(high_leverage$H))/nrow(high_leverage)

# add to original dataframe 
# see which observations have extremely high leverage (if any)
high_leverage_dat <- mass_SVL_SLR_residuals %>%
  mutate(row = rownames(.)) %>%
  left_join(., high_leverage, by = "row") %>%
  dplyr::filter(H > h_bar) 
high_leverage_dat
```

The points for individuals 4, 5, 6, 8, 9, 57, 64, 67, 87, and 123 seem to be high-leverage, so we will try removing them.

Check for influential points based on Cook's distance:

```{r}
# get Cook's distance 
cooks <- data.frame(c = cooks.distance(mass_SVL_SLR) # specify model name 
                    ) %>% mutate(row = rownames(.))

# add to original dataframe 
influential <- mass_SVL_SLR_residuals2 %>%
  mutate(row = rownames(.)) %>% 
  left_join(., cooks, by = "row")

# see moderately influential points 
cook_mod_inf <- influential %>% 
  dplyr::filter(c>0.5) 
cook_mod_inf
```

There are no even moderately-infuential points, at least based on Cook's distance, so there's nothing to potentially remove.

Create new SLR and check mean residual value after removing outliers and high leverage points:

```{r}
# create new dataframe with filtered data 
cleaned_SMI_dat <- mass_SVL_SLR_residuals2 %>% # already w outliers removed
  mutate(row = rownames(.)) %>%
  # add high leverage point info
  left_join(., high_leverage, by = "row") %>%
  # remove high leverage points
  dplyr::filter(H < h_bar) 

# model
mass_SVL_SLR2 <- lm(data = cleaned_SMI_dat, mass_g ~ SVL_mm)
summary(mass_SVL_SLR2)

# compute residuals
mass_SVL_SLR2_residuals <- cleaned_SMI_dat %>%
  mutate(y_hat = predict(mass_SVL_SLR2),
         e = residuals(mass_SVL_SLR2))

# check residuals values
mass_SVL_SLR2_residuals %>%
  summarise(mean_res = mean(e),
            med = median(e))
```

The residuals are much much smaller, so I believe it is the right choice to remove the high leverage points. The "cleaned_SMI_dat" will be used to calculate the equation for SMI.
 
 
### Step 2: make log-log relationship

plot and calculate SLR for filtered data

```{r}
cleaned_SMI_dat %>% 
  ggplot(data = .) + 
  geom_point(aes(x = log(SVL_mm),
                 y = log(mass_g), 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = log(SVL_mm), 
                  y = log(mass_g), 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("log-SVL") + 
  ylab("log-Mass") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0
)
```

SLR

```{r}
log_mass_SVL_SLR <- lm(data = cleaned_SMI_dat, 
                       log(mass_g) ~ log(SVL_mm))
summary(log_mass_SVL_SLR)
```

compute standardized major axis using this regression equation:

```{r}
r <- sqrt(0.8391) # Pearson's correlection coefficient (sqrt of R-squared)
b_OLS <- 3.0611 # regression slope
b_SMA <- b_OLS/r
```

also get a value for L0:

```{r}
L0 <- mean(cleaned_SMI_dat$SVL_mm)
```


### Step 3: calculate scaled mass index

(And join weather data.)

```{r}
morpho_blood_SMI <- morpho_blood_dat %>%
  mutate(SMI = mass_g * ((L0/SVL_mm) ^ b_SMA)) %>%
  left_join(all_times_weather, 
            by = c("collect_date_time")
            )
```


### Check

Look at the difference between regular mass and SMI:

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = mass_g,
                 y = SMI, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = mass_g, 
                  y = SMI, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Mass") + 
  ylab("SMI") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0
)
```








### Join Data 

Add CEWL and morpho_blood_SMI data together. 

```{r}
CEWL_data_full <- CEWL %>%
  left_join(morpho_blood_SMI, 
            by = c("date", "individual_ID")
            ) 
summary(CEWL_data_full)
```


### Final Formatting

redo the levels for body region:

```{r}
CEWL_data_full$region <- factor(CEWL_data_full$region,
                                levels = c("dors", "vent", 
                                           "head", "dewl", "mite"),
                                labels = c("Dorsum", "Ventrum", "Head",
                                           "Dewlap", "Mite Patch")
                                )
unique(CEWL_data_full$region)
```

NOTE: running this more than once overrides things, so be careful


# Check Data Distributions

## Histograms & Q-Q Plots

### SVL

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = SVL_mm)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("SVL (mm)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$SVL_mm)
# Normality test if p > .05, data is normal. Data is not normal.
shapiro.test(morpho_blood_SMI$SVL_mm)
```

### Mass

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = mass_g)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Mass (g)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$mass_g)
# Normality test if p > .05, data is normal. Data is not normal.
shapiro.test(morpho_blood_SMI$mass_g)
```

### SMI

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = SMI)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Scaled Mass Index (g)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$SMI)
# Normality test if p > .05, data is normal. Data is not normal.
shapiro.test(morpho_blood_SMI$SMI)
```

SMI is one of the few variables actually normally distributed!


### Hematocrit 

looks pretty normally distributed around ~35%, but not statistically normal

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = hematocrit_percent)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Hematocrit (%)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$hematocrit_percent)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$hematocrit_percent)
```

### Osmolality 

pretty normally distributed around ~370! :D

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = osmolality_mmol_kg)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("Osmolality (mmol/kg)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$osmolality_mmol_kg)
# Normality test if p > .05, data is normal. Data is normal
shapiro.test(morpho_blood_SMI$osmolality_mmol_kg)
```

### Cloacal Temperature 

seems normally distributed, but not normal

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = cloacal_temp_C)) +
  geom_histogram(color = "black", fill="steelblue", bins=10) + 
  theme_classic() +
  xlab("cloacal temperature (C)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$cloacal_temp_C)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$cloacal_temp_C)
```




### CEWL

```{r}
CEWL_data_full %>%
  ggplot(., aes(x = TEWL_g_m2h)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("TEWL_g_m2h") + 
  ylab("Count")
simple.eda(CEWL_data_full$TEWL_g_m2h)
CEWL_data_full %>%
  ggplot(., aes(x = TEWL_g_m2h)) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("TEWL_g_m2h") + 
  ylab("Count") + 
  facet_wrap(~region)

# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(CEWL_data_full$TEWL_g_m2h)

# Log transformation
shapiro.test(log(CEWL_data_full$TEWL_g_m2h))
# p-value improves to  0.00548, but is still significant
```


### Capture Temperature 

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = temp_C_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Temperature (C)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$temp_C_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$temp_C_interpol)

# log transform 
shapiro.test(log(morpho_blood_SMI$temp_C_interpol))
```


### Wind Speed at Capture

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = Wind_mph_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Wind Speed (mph)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$Wind_mph_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$Wind_mph_interpol)

# ln transformation doesn't fix non normality
shapiro.test(log(morpho_blood_SMI$Wind_mph_interpol))
```

### Solar Radiation at Capture

```{r}
morpho_blood_SMI %>%
  ggplot(., aes(x = Solar_rad_Wm2_interpol)) +
  geom_histogram(color = "black", fill="steelblue", bins=30) + 
  theme_classic() +
  xlab("Solar Radiation (W/m^2)") + 
  ylab("Count")
simple.eda(morpho_blood_SMI$Solar_rad_Wm2_interpol)
# Normality test if p > .05, data is normal. Data is not normal
shapiro.test(morpho_blood_SMI$Solar_rad_Wm2_interpol)

# Doesn't fix non normality
shapiro.test(log(morpho_blood_SMI$Solar_rad_Wm2_interpol))
```

## Conclusion

Osmolality and SMI were the only normally distributed variables. 

The following variables each had non-normal distributions:
- SVL (skewed left)
- mass (skewed left)
- hct (looks like a bell curve, but not very pretty)
- cloacal temp (skewed right)
- CEWL (skewed right, overall and for each region individually)
- capture temp (multimodal)
- wind speed (multimodal but sorta bell curve)
- solar radiation (multimodal)

All of the non-normal variables are likely to need transformation if they're included in the final model.



# Basic Figures

## osmolality & hematocrit

### Hct ~ SVL

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = hematocrit_percent, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("Hct") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```



### Osml ~ SVL

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = osmolality_mmol_kg, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```


### Hct ~ SMI

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SMI,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) +
  stat_smooth(aes(x = SMI, 
                  y = hematocrit_percent, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Scaled Mass Index") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```


### Osml ~ SMI

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SMI,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SMI, 
                  y = osmolality_mmol_kg), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = "gray",
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Scaled Mass Index") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```


### Hct ~ Sex

males have significantly higher hematocrit %

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = sex_M_F, 
                   y = hematocrit_percent, 
                   color = sex_M_F
                   ), 
               size = 1,
               alpha = 1) + 
  theme_classic() + 
  xlab("Sex") + 
  ylab("Hematocrit (%)") + 
  annotate("text", x = 1.5, y = 45, 
           label = "paste(italic(p), \" = 0.02\")", 
           parse = TRUE,
           size = 6) +
  ylim(10, 50) +
  scale_x_discrete(labels = c("F" = "Female",
                              "M" = "Male")) +
  scale_color_brewer(palette = "Set2") +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> hct_sex_fig
hct_sex_fig

# export figure
#ggsave(filename = "hct_sex_fig.jpeg",
 #      plot = hct_sex_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 6, height = 4)

# lms
lm_hct_sex_mass <- lm(hematocrit_percent ~ sex_M_F*mass_g - mass_g,
           data = morpho_blood_SMI)
summary(lm_hct_sex_mass)
lm_hct_sex <- lm(hematocrit_percent ~ sex_M_F,
           data = morpho_blood_SMI)
summary(lm_hct_sex)
```

Hematocrit is significantly predicted by sex, but the interaction between sex and mass is ~nonexistent. 


### Osml ~ Sex

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = sex_M_F, 
                   y = osmolality_mmol_kg, 
                   color = sex_M_F
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Sex", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Sex") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```

### Hct ~ Gravidity

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(sex_M_F == 'F') %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = gravid_Y_N, 
                   y = hematocrit_percent, 
                   color = gravid_Y_N
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Gravid", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Gravid (Females Only)") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```

### Osml ~ Gravidity

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(sex_M_F == 'F') %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = gravid_Y_N, 
                   y = osmolality_mmol_kg, 
                   color = gravid_Y_N
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Gravid", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Gravid (Females Only)") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```

### Hct ~ Sample Eye

Actually, any blood samples not taken from the right eye ended up being excluded or didn't have hematocrit values, so we can't test this difference.

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(blood_sample_eye %in% c("R", "L")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = blood_sample_eye, 
                   y = hematocrit_percent, 
                   color = blood_sample_eye
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Blood Sample Eye") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none"
)
```


### Osml ~ Sample Eye

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(blood_sample_eye %in% c("R", "L")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = blood_sample_eye, 
                   y = osmolality_mmol_kg, 
                   color = blood_sample_eye
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1") ) +
  theme_classic() + 
  xlab("Blood Sample Eye") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```

There IS a significant difference, but upon further inspection, the number of blood draws taken from the right postorbital sinus vs left or both is so uneven, this would be unhelpful in the actual model.

### Hct ~ Hemolyzed/Not

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(hemolyzed %in% c("Y", "N")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = hemolyzed, 
                   y = hematocrit_percent, 
                   color = hemolyzed
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1", "green4", "salmon1") ) +
  theme_classic() + 
  xlab("Whether or not Sample Hemolyzed") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```



### Osml ~ Hemolyzed/Not

```{r}
morpho_blood_SMI %>% 
  dplyr::filter(hemolyzed %in% c("Y", "N")) %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = hemolyzed, 
                   y = osmolality_mmol_kg, 
                   color = hemolyzed
                   ), 
               size = 1,
               alpha = 0.6) + 
  scale_colour_manual(name = "Blood Sample Eye", 
                      values = c("green4", "salmon1", "green4", "salmon1") ) +
  theme_classic() + 
  xlab("Whether or not Sample Hemolyzed") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```

Osmolality in hemolyzed samples versus not are significantly different! This is an unfortunate trait of the dataset, and not something we are specifically interested in testing, so we will include it as a random factor in the LMM.

### Hct ~ Week

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = hematocrit_percent, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  theme_classic() + 
  xlab("Sampling Date") + 
  ylab("Hematocrit") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```



### Osml ~ Week

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = osmolality_mmol_kg, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  theme_classic() + 
  xlab("Date") + 
  ylab("Osmolality (mmol / kg)") + 
  annotate("text", x = 1, y = 365, label = "a", size = 6) +
  annotate("text", x = 2, y = 390, label = "b", size = 6) +
  annotate("text", x = 3, y = 437, label = "c", size = 6) +
  annotate("text", x = 4, y = 427, label = "c", size = 6) +
  annotate("text", x = 5, y = 417, label = "d", size = 6) +
  annotate("text", x = 6, y = 447, label = "d", size = 6) +
  scale_x_discrete(labels = c("2021-04-05" = "Apr 5", 
                              "2021-04-19" = "Apr 19",
                              "2021-04-26" = "Apr 26",
                              "2021-05-03" = "May 3", 
                              "2021-05-10" = "May 10",
                              "2021-05-17" = "May 17")) +
  scale_color_brewer(palette = "Set2") +
  ylim(300, 450) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> osml_date_fig
osml_date_fig

# export figure
#ggsave(filename = "osml_date_fig.tiff",
 #      plot = osml_date_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)

# lm
lm_osml_wk <- glm(osmolality_mmol_kg ~ date,
           data = morpho_blood_SMI)
summary(lm_osml_wk)
```

Osmolality was VERY different by week, and that was not easily attributable to climate factors (see below). We also experienced technical difficulties with the osmometer between some weeks, so some of the variation may be attributable to technical error. Thus date/week will be a good random factor to include in the LMM.

distinguish pairwise differences using an ANOVA:

```{r}
osml_date_aov <- aov(osmolality_mmol_kg ~ as.factor(date), 
                     data = morpho_blood_SMI)
TukeyHSD(osml_date_aov)
```




### Osml ~ VPD

```{r}
my_blue <- RColorBrewer::brewer.pal(8, "Set2")[3]
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = VPD_kPa_int,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = VPD_kPa_int, 
                  y = osmolality_mmol_kg), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = my_blue,
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Vapor Pressure Deficit (kPa)") + 
  #ylab("Osmolality (mmol/kg)") + 
  ylab("") +
  xlim(0, 2) +
  ylim(300, 450) +
  annotate("text", x = 1.8, y = 320, 
           label = "paste(italic(R) ^ 2, \" = 0.23\")", 
           parse = TRUE,
           size = 6) +
  annotate("text", x = 1.8, y = 305, 
           label = "paste(italic(p), \" < 0.0001\")", 
           parse = TRUE,
           size = 6) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        axis.text.y = element_blank(),
        legend.text.align = 0,
        plot.margin = unit(c(0.1,0,0.1,0.45), "cm"),
) -> osml_vpd_fig
osml_vpd_fig

# export figure
#ggsave(filename = "osml_abhum_fig.jpeg",
 #      plot = osml_abhum_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 6, height = 4)
```



### Hct ~ VPD

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = VPD_kPa_int,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = VPD_kPa_int, 
                  y = hematocrit_percent), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = "blue",
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("VPD at Capture (kPa)") + 
  ylab("Hematocrit (%)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```


### Hct ~ Temperature

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = temp_C_interpol,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = temp_C_interpol, 
                  y = hematocrit_percent), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = "maroon",
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient Temperature at Capture (C)") + 
  ylab("Hematocrit (%)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```

### Osml ~ Temperature

```{r}
my_red <- RColorBrewer::brewer.pal(8, "Set2")[4]

morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = temp_C_interpol,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = temp_C_interpol, 
                  y = osmolality_mmol_kg), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              color = my_red,
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient Temperature (°C)") + 
  ylab("Plasma Osmolality\n(mmol / kg)") + 
  annotate("text", x = 23, y = 320, 
           label = "paste(italic(R) ^ 2, \" = 0.29\")", 
           parse = TRUE,
           size = 6) +
  annotate("text", x = 23, y = 305, 
           label = "paste(italic(p), \" < 0.0001\")", 
           parse = TRUE,
           size = 6) +
  xlim(14, 24) +
  ylim(300,450) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        legend.text.align = 0,
        plot.margin = unit(c(0.1,0,0.1,0.45), "cm")
) -> osml_temp_fig
osml_temp_fig

# export figure
#ggsave(filename = "osml_temp_fig.jpeg",
 #      plot = osml_temp_fig,
  #     path = "./final_figures",
   #    device = "jpeg",
    #   dpi = 1200,
     #  width = 6, height = 4)
```

### Hct ~ Individual

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = individual_ID,
                 y = hematocrit_percent, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = individual_ID, 
                  y = hematocrit_percent, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Individual Lizard") + 
  ylab("Hematocrit (%)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```

### Osml ~ Individual

```{r}
morpho_blood_SMI %>% 
  ggplot(data = .) + 
  geom_point(aes(x = individual_ID,
                 y = osmolality_mmol_kg, 
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = individual_ID, 
                  y = osmolality_mmol_kg, 
                  ), 
              formula = y ~ x, 
              method = "lm", 
              color = "gray",
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Individual Lizard") + 
  ylab("Osmolality") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```



## Osmolality Multi-Figure

```{r}
ggarrange(osml_temp_fig, osml_vpd_fig,
          ncol = 2, nrow = 1,
          labels = c("A", "B", "C", "D", "E", "F"),
          hjust = c(-2, -0.5),
          font.label = list(size = 24, face = "bold", color ="black")
          ) -> osml_multi_fig
osml_multi_fig
# export figure
ggsave(filename = "osml_multi_fig.jpeg",
       plot = osml_multi_fig,
       path = "./final_figures",
       device = "jpeg",
       dpi = 1200,
       width = 12, height = 4)
```




## What affects evaporative water loss?

Potential relationships:
- CEWL ~ date/week, 
        individual, 
        SVL, 
        SMI, 
        gravidity, 
        hct, 
        osml, 
        cloacal temp, 
        ambient temp, 
        ambient RH, 
        measurement temp,
        measurement RH,
        **body region**

### CEWL ~ Body Region

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = (region), 
                   y = (TEWL_g_m2h), 
                   color = region
                   ), 
               size = 1,
               alpha = 1) +
  geom_jitter(aes(x = (region), 
                   y = TEWL_g_m2h, 
                   color = region
                   ), 
               size = 0.6,
               alpha = 0.4) +
  geom_point(aes(x = (region), 
                   y = mean(TEWL_g_m2h), 
                   color = region,
                   ), 
               size = 6,
               alpha = 1) +
  theme_classic() + 
  xlab("Body Region") + 
  ylab(bquote('CEWL (g / '*m^2~h*')')) + 
  annotate("text", x = 1, y = 64, label = "a", size = 6) +
  annotate("text", x = 2, y = 77, label = "a", size = 6) +
  annotate("text", x = 3, y = 95, label = "a", size = 6) +
  annotate("text", x = 4, y = 65, label = "b", size = 6) +
  annotate("text", x = 5, y = 106, label = "c", size = 6) +
  scale_color_brewer(palette = "Set2") +
  ylim(1, 110) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> CEWL_region_fig
CEWL_region_fig

# export figure
ggsave(filename = "CEWL_region_fig.jpeg",
       plot = CEWL_region_fig,
       path = "./final_figures",
       device = "jpeg",
       dpi = 1200,
       width = 6, height = 4)
```


### Body Region Ratios

```{r}
CEWL_mite <- CEWL_data_full %>%
  dplyr::filter(region == "Mite Patch") %>%
  dplyr::select(mite_CEWL = TEWL_g_m2h, individual_ID)
CEWL_dewl <- CEWL_data_full %>%
  dplyr::filter(region == "Dewlap")%>%
  dplyr::select(dewl_CEWL = TEWL_g_m2h, individual_ID)
CEWL_head <- CEWL_data_full %>%
  dplyr::filter(region == "Head") %>%
  dplyr::select(head_CEWL = TEWL_g_m2h, individual_ID)
CEWL_vent <- CEWL_data_full %>%
  dplyr::filter(region == "Ventrum") %>%
  dplyr::select(vent_CEWL = TEWL_g_m2h, individual_ID)
CEWL_dors <- CEWL_data_full %>%
  dplyr::filter(region == "Dorsum") %>%
  dplyr::select(dors_CEWL = TEWL_g_m2h, individual_ID)

by_region_CEWL <- CEWL_mite %>%
  left_join(CEWL_dewl, by = "individual_ID") %>%
  left_join(CEWL_head, by = "individual_ID") %>%
  left_join(CEWL_vent, by = "individual_ID") %>%
  left_join(CEWL_dors, by = "individual_ID") %>%
  mutate(mite_dors = mite_CEWL/dors_CEWL,
         dewl_dors = mite_CEWL/dors_CEWL,
         head_dors = mite_CEWL/dors_CEWL,
         vent_dors = mite_CEWL/dors_CEWL,
         dors_dors = mite_CEWL/dors_CEWL,
         )

ratio_mite <- by_region_CEWL %>%
  dplyr::select(individual_ID, ratio_to_dors = mite_dors) %>%
  mutate(region = "Mite Patch")
ratio_dewl <- by_region_CEWL %>%
  dplyr::select(individual_ID, ratio_to_dors = dewl_dors) %>%
  mutate(region = "Dewlap")
ratio_head <- by_region_CEWL %>%
  dplyr::select(individual_ID, ratio_to_dors = head_dors) %>%
  mutate(region = "Head")
ratio_vent <- by_region_CEWL %>%
  dplyr::select(individual_ID, ratio_to_dors = vent_dors) %>%
  mutate(region = "Ventrum")
ratio_dors <- by_region_CEWL %>%
  dplyr::select(individual_ID, ratio_to_dors = dors_dors) %>%
  mutate(region = "Dorsum")

vert_ratios <- ratio_mite %>%
  rbind(ratio_dewl) %>%
  rbind(ratio_head) %>%
  rbind(ratio_vent) %>%
  rbind(ratio_dors)
```


```{r}
vert_ratios %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = (region), 
                   y = ratio_to_dors, 
                   color = region
                   ), 
               size = 1,
               alpha = 1) +
  geom_jitter(aes(x = (region), 
                   y = ratio_to_dors, 
                   color = region
                   ), 
               size = 1,
               alpha = 0.3) +
  geom_point(aes(x = (region), 
                   y = mean(ratio_to_dors), 
                   color = region
                   ), 
               size = 5,
               alpha = 1) +
  theme_classic() + 
  xlab("Body Region") + 
  ylab(bquote('CEWL Ratio to Dorsal (g / '*m^2~h*')')) + 
  annotate("text", x = 1, y = 64, label = "a", size = 6) +
  annotate("text", x = 2, y = 77, label = "b", size = 6) +
  annotate("text", x = 3, y = 95, label = "b", size = 6) +
  annotate("text", x = 4, y = 65, label = "a", size = 6) +
  annotate("text", x = 5, y = 106, label = "b", size = 6) +
  scale_color_brewer(palette = "Set2") +
  ylim(1, 10) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text.align = 0,
        legend.position = "none"
) -> CEWL_region_fig3
CEWL_region_fig3

# export figure
ggsave(filename = "CEWL_region_fig3.jpeg",
       plot = CEWL_region_fig3,
       path = "./final_figures",
       device = "jpeg",
       dpi = 1200,
       width = 6, height = 4)
```




### CEWL ~ Osmolality

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = osmolality_mmol_kg,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = osmolality_mmol_kg, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Osmolality") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)


# Facet ggplot
ggplot(aes(osmolality_mmol_kg, TEWL_g_m2h), data = CEWL_data_full) + 
  geom_point() + 
  stat_smooth(aes(x = osmolality_mmol_kg, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 )+
    theme_classic() + 
  xlab("Osmolality") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0) +
  facet_wrap(~ region) # create a facet for each body region
```


### CEWL ~ Hematocrit

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = hematocrit_percent,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = hematocrit_percent, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Hematocrit") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```


### CEWL ~ Cloacal Temperature

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = cloacal_temp_C,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = cloacal_temp_C, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1) + 
  theme_classic() + 
  xlab("Cloacal Temperature (°C)") + 
  ylab("") +
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(20, 28) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 26),
        plot.margin = unit(c(0.1,0,0.35,0.45), "cm"),
        legend.text.align = 0,
        legend.position = "none") -> CEWL_ctemp_fig
CEWL_ctemp_fig

# export figure
#ggsave(filename = "CEWL_ctemp_fig.tiff",
 #      plot = CEWL_ctemp_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)
```




### CEWL ~ Capture Temperature

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = temp_C_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = temp_C_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  scale_color_brewer(palette = "Set2") +
  theme_classic() + 
  xlab("Ambient Temperature (°C)") + 
  #ylab("") +
  ylim(1, 100) +
  ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 26),
        plot.margin = unit(c(0.1,0,0.35,0.1), "cm"),
        legend.text.align = 0,
        legend.position = "none"
) -> cap_temp_CEWL
cap_temp_CEWL
```


### CEWL ~ Capture VPD

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_jitter(aes(x = VPD_kPa_int,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = VPD_kPa_int, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Vapor Pressure Deficit (kPa)") + 
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  ylab("") +
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(0.3, 1.6) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 26),
        legend.text.align = 0,
        plot.margin = unit(c(0.1,0,0.35,0.45), "cm"),
        legend.position = "none"
        #legend.position = c(0.15, 0.85)
         ) -> CEWL_vpd_fig
CEWL_vpd_fig

# export figure
#ggsave(filename = "CEWL_vpd_fig.tiff",
 #      plot = CEWL_vpd_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)
```


### CEWL ~ Wind Speed

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = Wind_mph_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = Wind_mph_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  scale_color_brewer(palette = "Set2") +
  xlab("Wind Speed (mph)") + 
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  ylab("") +
  ylim(0,100) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 26),
        axis.text.y = element_blank(),
        plot.margin = unit(c(0.1,0,0.35,0.45), "cm"),
        legend.text.align = 0,
        legend.position = "none"
) -> wind_CEWL_plot
wind_CEWL_plot
```


### CEWL ~ Solar Rad

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = Solar_rad_Wm2_interpol,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = Solar_rad_Wm2_interpol, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  scale_color_brewer(palette = "Set2") +
  xlab(bquote('Solar Radiation (W/'*m^2*')')) + 
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  ylab("") +
  ylim(0,100) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 26),
        axis.text.y = element_blank(),
        plot.margin = unit(c(0.1,0,0,0.45), "cm"),
        legend.text.align = 0,
        legend.position = "none"
) -> sorad_CEWL_plot
sorad_CEWL_plot
```



### CEWL ~ Measurement Temperature

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = ambient_temp_C,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = ambient_temp_C, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  scale_color_brewer(palette = "Set2") +
  xlab("Ambient Temperature During Measurement") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        legend.text.align = 0,
        legend.position = "none"
)
```


### CEWL ~ Measurement VPD

Very interesting relationship! Mite patch CEWL decreases as VPD increases, but every other location appears to increase. In this case, an interaction term is warranted.

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = VPD_kPa,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = VPD_kPa, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Ambient VPD During Measurement") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```

### CEWL ~ Individual

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = individual_ID,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = individual_ID, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Individual Lizard") + 
  ylab("CEWL") + 
  
  # just to get a better look
  # ylim(5, 40) +
  
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```

### CEWL ~ SVL

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SVL_mm,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = SVL_mm, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("SVL") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```


### CEWL ~ SMI

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = SMI,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = SMI, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Scaled Mass Index (g)") + 
  ylab(bquote('CEWL (g / '*m^2~h*')')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(2, 16) +
  scale_x_continuous(breaks = c(seq(2, 16, by = 2))) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 18),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 14),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 12),
        plot.margin = unit(c(0.1,0.5,0.1,0.1), "cm"),
        legend.text.align = 0,
        legend.position = c(0.15, 0.85)
         ) -> CEWL_SMI_fig
CEWL_SMI_fig

# export figure
#ggsave(filename = "CEWL_mass_fig.tiff",
 #      plot = CEWL_mass_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)
```

### CEWL ~ Mass

Head has an opposite trend from all the other body regions, so we need an interaction term.

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = mass_g,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.4) + 
  stat_smooth(aes(x = mass_g, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Mass (g)") + 
  ylab("") +
  #ylab(bquote('CEWL (g/'*m^2*'h)')) + 
  #annotate("text", x = 1, y = 65, label = "a", size = 6) +
  scale_color_brewer(palette = "Set2",
                     name = "") +
  ylim(1, 100) +
  xlim(2, 16) +
  scale_x_continuous(breaks = c(seq(2, 16, by = 2))) +
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 22),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 16),
        axis.text.y = element_blank(),
        legend.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 26),
        plot.margin = unit(c(0.1,0,0.35,0.45), "cm"),
        legend.text.align = 0,
        legend.position = "none"
        #legend.position = c(0.5, 0.5)
         ) -> CEWL_mass_fig
CEWL_mass_fig

# MUST CHANGE COMMENTS ABOVE to produce this
CEWL_legend <- as_ggplot(get_legend(CEWL_mass_fig))

# export figure
#ggsave(filename = "CEWL_mass_fig.tiff",
 #      plot = CEWL_mass_fig,
  #     path = "./final_figures",
   #    device = "tiff",
    #   dpi = 1200,
     #  width = 6, height = 4)
```

### CEWL ~ Sex

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = sex_M_F, 
                   y = TEWL_g_m2h, 
                   color = sex_M_F
                   ), 
               size = 1,
               alpha = 0.6) + 
  facet_wrap(~region) +
  scale_color_manual(values = c("royalblue1", "mediumorchid")) +
  scale_x_discrete(breaks = c(1,2,3)) +
  theme_classic() + 
  xlab("Sex") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```

### CEWL ~ Gravidity

```{r}
CEWL_data_full %>% 
  dplyr::filter(sex_M_F == "F") %>%
  ggplot(data = .) + 
  geom_boxplot(aes(x = gravid_Y_N, 
                   y = TEWL_g_m2h, 
                   color = gravid_Y_N
                   ), 
               size = 1,
               alpha = 0.6) + 
  facet_wrap(~region) +
  scale_color_manual(values = c("royalblue1", "mediumorchid")) +
  scale_x_discrete(breaks = c(1,2,3)) +
  theme_classic() + 
  xlab("Female Gravid or Not") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```


### CEWL ~ Week

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_boxplot(aes(x = as.factor(date), 
                   y = TEWL_g_m2h, 
                   color = as.factor(date)
                   ), 
               size = 1,
               alpha = 0.6) + 
  facet_wrap(~region) + # could not figure out how to change facet labels without changing underlying data
  scale_color_manual(values = c("royalblue1", "mediumorchid", "seagreen4",
                                "royalblue1", "mediumorchid", "seagreen4")) +
  scale_x_discrete(breaks = c(1,2,3)) +
  theme_classic() + 
  xlab("Date") + 
  ylab("CEWL") + 
  theme(text = element_text(color = "black", family = "sans", size = 12),
        axis.text = element_text(color = "black", family = "sans", size = 10),
        legend.text.align = 0,
        legend.position = "none")
```


### CEWL ~ holding time

```{r}
CEWL_data_full %>% 
  ggplot(data = .) + 
  geom_point(aes(x = hold_time,
                 y = TEWL_g_m2h, 
                 color = region
                 ), 
             size = 1, 
             alpha = 0.6) + 
  stat_smooth(aes(x = hold_time, 
                  y = TEWL_g_m2h, 
                  color = region
                  ), 
              formula = y ~ x, 
              method = "lm", 
              se = F, 
              size = 1.6, 
              alpha = 1 ) + 
  theme_classic() + 
  xlab("Holding Time (minutes)") + 
  ylab("CEWL (g/m^2/hr)") + 
  theme(text = element_text(color = "black", 
                            family = "sans", 
                            size = 12),
        axis.text = element_text(color = "black", 
                                 family = "sans", 
                                 size = 10),
        legend.text.align = 0)
```



## CEWL Multi-Figure

```{r}
ggarrange(CEWL_vpd_fig, wind_CEWL_plot, 
          cap_temp_CEWL, sorad_CEWL_plot, 
          CEWL_ctemp_fig, CEWL_mass_fig,
          labels = c("A", "B", "C", "D", "E", "F"),
          font.label = list(size = 24, face = "bold", color ="black"),
          ncol = 2, nrow = 3,
          common.legend = TRUE,
          legend = "bottom"
          ) -> CEWL_multi_fig
CEWL_multi_fig
# export figure
ggsave(filename = "CEWL_multi_fig.jpeg",
       plot = CEWL_multi_fig,
       path = "./final_figures",
       device = "jpeg",
       dpi = 1200,
       width = 12, height = 14)
```



# LMMs


## Hydration

### Models
                
Start with all the variables that may explain osmolality variation. Female gravidity cannot be included because of the low sample size and number of contrasts.

FULL model:

```{r, hydration model 1}
# model 1
hydrat_mod1 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                            # start with interaction + singular effect
                           VPD_kPa_int*temp_C_interpol +
                            # other potentially important factors
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + SVL_mm + mass_g + sex_M_F +
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod1)
```


use VIF to look for multicollinearity:

```{r}
hydrat_mod1_VIFs <- data.frame(VIF = car::vif(hydrat_mod1)) %>%
  arrange(VIF)
hydrat_mod1_VIFs
```

Remove the highest VIF variables one at a time. First, the temp*VPD interaction.

```{r, hydration model 2}
# model 2
hydrat_mod2 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                           VPD_kPa_int + temp_C_interpol +
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + SVL_mm + mass_g + sex_M_F +
                            # random effects
                            (1|date) + (1|hemolyzed)) 
hydrat_mod2_VIFs <- data.frame(VIF = car::vif(hydrat_mod2)) %>%
  arrange(VIF)
hydrat_mod2_VIFs
```

drop mass.

```{r, hydration model 3}
# model 3
hydrat_mod3 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                           VPD_kPa_int + temp_C_interpol +
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + SVL_mm + sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
hydrat_mod3_VIFs <- data.frame(VIF = car::vif(hydrat_mod3)) %>%
  arrange(VIF)
hydrat_mod3_VIFs
```

drop temperature

```{r, hydration model 4}
# model 4
hydrat_mod4 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                           VPD_kPa_int +
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + SVL_mm + sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
hydrat_mod4_VIFs <- data.frame(VIF = car::vif(hydrat_mod4)) %>%
  arrange(VIF)
hydrat_mod4_VIFs
```

Okay, now that all VIFs are reasonable values, we can do the remaining model selection based on AIC and t-value.

```{r}
summary(hydrat_mod4)
drop1(hydrat_mod4)
```

drop SVL:

```{r, hydration model 5}
# model 5
hydrat_mod5 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                           VPD_kPa_int +
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod5)
drop1(hydrat_mod5)
```

drop VPD:

```{r, hydration model 6}
# model 6
hydrat_mod6 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod6)
drop1(hydrat_mod6)
```

drop SMI:

```{r, hydration model 7}
# model 7
hydrat_mod7 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod7)
drop1(hydrat_mod7)
```

drop sex:

```{r, hydration model 8}
# model 8
hydrat_mod8 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod8)
drop1(hydrat_mod8)
```


drop solar radiation:

```{r, hydration model 9}
# model 9
hydrat_mod9 <- lme4::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                            Wind_mph_interpol +
                            # random effects
                            (1|date) + (1|hemolyzed)) 
```

finally, test the null model

```{r, hydration model null}
hydrat_mod_null <- lme4::lmer(data = hydrat_mod_dat,
                          osmolality_mmol_kg ~ 1 +
                            (1|date) + (1|hemolyzed))
```


### Selection

models 4-9 and the null model are the ones we should compare. models 1-3 had serious multicollinearity thus are not trustworthy models.

```{r osml mod compare}
hydrat_models <- list(hydrat_mod4, hydrat_mod5, hydrat_mod6,
               hydrat_mod7, hydrat_mod8, hydrat_mod9, 
               hydrat_mod_null)

#specify model names
hydrat_mod_names <- c('(model 4) ~ VPD, Wind, Solar, SMI, SVL, sex', 
                     '(model 5) ~ VPD, Wind, Solar, SMI, sex', 
                     '(model 6) ~ Wind, Solar, SMI, sex',
                     '(model 7) ~ Wind, Solar, sex', 
                     '(model 8) ~ Wind, Solar', 
                     '(model 9) ~ Wind', 
                     'null model')
#calculate AIC of each model
hydrat_AICc <- data.frame(aictab(cand.set = hydrat_models, 
                                 modnames = hydrat_mod_names))
hydrat_AICc
```


Re-run top 2 models using lmertest to get p-values:

```{r}
hydrat_mod5p <- lmerTest::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                           VPD_kPa_int +
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod5p)
hydrat_mod4p <- lmerTest::lmer(data = hydrat_mod_dat,
                          # response variable
                          osmolality_mmol_kg ~ 
                           VPD_kPa_int +
                            Wind_mph_interpol + Solar_rad_Wm2_interpol +
                            SMI + SVL_mm + sex_M_F + 
                            # random effects
                            (1|date) + (1|hemolyzed)) 
summary(hydrat_mod4p)
```


### Check LM Assumptions

```{r}
plot(hydrat_mod4)
plot(hydrat_mod5)
```


residuals look fantastic for both


### Export

We should save the information for the top two models, as well as the table showing the rankings of the different models.

```{r}
write.csv(hydrat_AICc, "./best models/osml_mod_rankings.csv")
write.csv(broom.mixed::tidy(hydrat_mod5p), 
          "./best models/osml_best_mod1.csv")
write.csv(broom.mixed::tidy(hydrat_mod4p), 
          "./best models/osml_best_mod2.csv")
```


### Check LM Assumptions (Hydration Model)

First, get residuals:

```{r}
res_hydrat_mod <- hydrat_mod_dat %>%
  mutate(y_hat = predict(hydrat_mod2),
         e = residuals(hydrat_mod2))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = res_hydrat_mod, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("Hydration Best Model") +
  geom_hline(yintercept = 0)
```

It looks pretty evenly distributed. No clear patterning, so linearity and equal error variance should be satisfied.

Brown-Forsythe test to statistically check equal variance:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)

```{r}
# need to create the right data & format first
bf_data_temp <- res_hydrat_mod %>%
  dplyr::filter(complete.cases(temp_C_interpol)) %>%
  dplyr::mutate(middle = median(temp_C_interpol),
                side = temp_C_interpol > middle)
bf_data_temp$side <- as.factor(bf_data_temp$side)

# now run test
bf.test(formula = e ~ side, # y~x
        data = bf_data_temp, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )

# need to create the right data & format first
bf_data_vpd <- res_hydrat_mod %>%
  dplyr::filter(complete.cases(VPD_kPa_int)) %>%
  dplyr::mutate(middle = median(VPD_kPa_int),
                side = VPD_kPa_int > middle)
bf_data_vpd$side <- as.factor(bf_data_vpd$side)

# now run test
bf.test(formula = e ~ side, # y~x
        data = bf_data_vpd, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is satisfied.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(res_hydrat_mod$e)
shapiro.test(res_hydrat_mod$e)
```

Normality is satisfied.


## Multicollinearity

### Conclusion

hydrat_mod2 is the best model to predict osmolality, and the model satisfies all linear regression conditions/assumptions.



## CEWL

Based on the simple linear models and figures above, CEWL should be predicted by:
- body region
- cloacal temperature at measurement
- capture temperature, VPD, wind speed, and solar radiation
- ambient temperature during measurement
- SVL and mass
- hold time (time between capture vs measurement)
- individual ID (as a random effect)

Prep dataframe for models:

```{r}
CEWL_mod_dat <- CEWL_data_full %>% 
  # select variables of interest
  dplyr::select(date,
                hold_time,
                individual_ID,
                mass_g,
                SVL_mm, 
                TEWL_g_m2h,
                region,
                cloacal_temp_C,
                temp_C_interpol,
                VPD_kPa_int,
                Wind_mph_interpol,
                Solar_rad_Wm2_interpol,
                ambient_temp_C
                ) %>%
  dplyr::filter(complete.cases(.)) # removes 69 observations
```


### Multicollinearity

Check for multicollinearity among independent variables:

```{r}
CEWL_mod_dat %>% 
  # get rid of dependent variable
  dplyr::select(-TEWL_g_m2h, individual_ID) %>%
  # multicollinearity plot
  pairs(.)

# also make another plot with r-sq values
# non-numeric variables don't work for this
CEWL_mod_dat %>% 
  # select variables of interest
  dplyr::select(-TEWL_g_m2h, -date, -region, -individual_ID) %>% 
  # multicollinearity plot
  chart.Correlation(., histogram = F, pch = 19)
```

Mass and SVL are very collinear variables that should not be used in combination. Cloacal temp and hold time are pretty collinear, which makes sense; as we held them, they got cooler because they were inside and not basking. Individual ID and VPD are also pretty collinear, but it's less intuitive. Temperature and solar radiation, as well as VPD and solar radiation, are each collinear pairs. We will use model selection to figure out which variable from each collinear pair is better to include in the model. Temperature and VPD are very badly collinear... But as I tried above, centering one or both did not help.



### Models & Selection

This is the full model with every potential variable and interaction indicated to be meaningful based on figures and SLRs.

```{r}
# model 1
CEWL_mod1 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g + ambient_temp_C +
                                     temp_C_interpol +
                                     VPD_kPa_int) +
                         hold_time + SVL_mm +
                         cloacal_temp_C +
                         temp_C_interpol:VPD_kPa_int +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod1)
```


Check which variables to drop:

```{r}
drop1(CEWL_mod1)
```

Based on AIC, dropping SVL, hold time, wind speed, region:ambient_temp_C, and temp_C_interpol:VPD_kPa_int would result in a better model. 

Start with region:ambient_temp_C and temp_C_interpol:VPD_kPa_int interactions:

```{r}
# model 2
CEWL_mod2 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     VPD_kPa_int) +
                         hold_time + SVL_mm +
                         cloacal_temp_C +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod2)

# compare
anova(CEWL_mod2, CEWL_mod1)
```

AIC improved somewhat and we do not lose a significant amount of predictive power using alpha 0.05, so the reduced model is better. Continue dropping...

Check drop terms again:

```{r}
drop1(CEWL_mod2)
```

Hold time and SVL should still be deleted.

```{r}
# model 3
CEWL_mod3 <- lme4::lmer(data = CEWL_mod_dat,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     VPD_kPa_int) +
                         cloacal_temp_C +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod3)

# compare
anova(CEWL_mod3, CEWL_mod1)
anova(CEWL_mod3, CEWL_mod2)
```

Once again, the AIC is slightly lower, and our model fit is not significantly worse by going to model 3, so the reduced model is better.

Check drop terms again to see if anything else could potentially be removed:

```{r}
drop1(CEWL_mod3)
```

We have arrived at the best model based on AIC.


Since we dropped a lot of variables, I want to go back and make sure to use as much data as possible in the final model, so I can add back in observations with missing values for variables no longer included in the reduced model.
 
```{r}
# filter
CEWL_mod_dat2 <- CEWL_data_full %>% 
  # select variables of interest
  dplyr::select(individual_ID,
                mass_g,
                TEWL_g_m2h,
                region,
                cloacal_temp_C,
                temp_C_interpol,
                VPD_kPa_int,
                Wind_mph_interpol,
                Solar_rad_Wm2_interpol,
                ) %>%
  dplyr::filter(complete.cases(.)) # able to have 5 more observations

# redo best model

# model 3
CEWL_mod3_adj <- lmerTest::lmer(data = CEWL_mod_dat2,
                        TEWL_g_m2h ~
                         region * (mass_g +
                                     temp_C_interpol +
                                     VPD_kPa_int) +
                         cloacal_temp_C +
                         Wind_mph_interpol +
                         Solar_rad_Wm2_interpol + 
                         (1|individual_ID)) 
summary(CEWL_mod3_adj)
```



### Best Model

The best model is CEWL predicted by: body region and its interaction with mass and capture temp and VPD, cloacal temperature, solar radiation at capture time, and individual ID as a random effect.

```{r}
# save best model info
CEWL_best_mod <- broom.mixed::tidy(CEWL_mod3_adj)
# export 
#write.csv(CEWL_best_mod, "./best models/CEWL_best_mod_vals.csv")
```



### Check LM Assumptions

First, get residuals:

```{r}
CEWL_mod_res <- CEWL_mod_dat2 %>%
  mutate(y_hat = predict(CEWL_mod3_adj),
         e = residuals(CEWL_mod3_adj))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = CEWL_mod_res, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("CEWL Model Residuals") +
  geom_hline(yintercept = 0)
```

It's definitely making a fan shape. :(

Brown-Forsythe test to statistically check equal variance, for each continuous predictor variable:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)


```{r}
# need to create the right data & format first
bf_data_CEWL <- CEWL_mod_res %>%
  dplyr::mutate(middle_mass = median(mass_g), # mass
                side_mass = as.factor(mass_g > middle_mass),
                # solar radiation
                middle_sorad = median(Solar_rad_Wm2_interpol),
                side_sorad = as.factor(Solar_rad_Wm2_interpol > middle_sorad), 
                # temperature
                middle_temp = median(temp_C_interpol),
                side_temp = as.factor(temp_C_interpol > middle_temp),
                # VPD
                middle_absh = median(VPD_kPa_int),
                side_absh = as.factor(VPD_kPa_int > middle_absh),
                middle_ct = median(cloacal_temp_C),
                side_ct = as.factor(cloacal_temp_C > middle_ct)
                )


# now run test
bf.test(formula = e ~ side_absh, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_temp, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_sorad, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_ct, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_mass, # y~x
        data = bf_data_CEWL, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is satisfied for all 5 continuous predictor variables.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(CEWL_mod_res$e)
shapiro.test(CEWL_mod_res$e)
```

not normal!


### Test Transformations 

Can I improve satisfaction of LM assumptions by transforming the dependent variable? In particular, conditions of linearity and normality are not met. 

```{r}
# sqrt(TEWL)
CEWL_data_full %>%
  ggplot(., aes(x = sqrt(TEWL_g_m2h))) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("sqrt(CEWL)") + 
  ylab("Count") + 
  facet_wrap(~region)

# log(TEWL)
CEWL_data_full %>%
  ggplot(., aes(x = log(TEWL_g_m2h))) +
  geom_histogram(color = "black", fill="steelblue", bins=50) + 
  theme_classic() +
  xlab("LOG(CEWL)") + 
  ylab("Count") + 
  facet_wrap(~region)
```


Log transforming seems to be pretty effective across body regions.



### Transform & Re-Model

I will log-transform CEWL and see whether it makes the models satisfy LMM assumptions better.

Run CEWL model 4 with log-transformed CEWL:

```{r}
# log-transformed model 3
CEWL_mod3_t <- lme4::lmer(data = CEWL_mod_dat2,
                          log(TEWL_g_m2h) ~
                            region * (mass_g +
                                     temp_C_interpol +
                                     VPD_kPa_int) +
                            cloacal_temp_C + 
                            Solar_rad_Wm2_interpol +
                            Wind_mph_interpol +
                            (1|individual_ID)) 
summary(CEWL_mod3_t)

# compare
anova(CEWL_mod3_t, CEWL_mod3_adj)
```


re-run using lmertest for p-values:

```{r}
CEWL_mod_final <- lmerTest::lmer(data = CEWL_mod_dat2,
                          log(TEWL_g_m2h) ~
                            region * (mass_g +
                                     temp_C_interpol +
                                     VPD_kPa_int) +
                            cloacal_temp_C + 
                            Solar_rad_Wm2_interpol +
                            Wind_mph_interpol +
                            (1|individual_ID)) 
summary(CEWL_mod_final)
```



### Re-Check Assumptions (transformed model 3)

First, get residuals:

```{r}
CEWL_t_mod_res <- CEWL_mod_dat2 %>%
  mutate(y_hat = predict(CEWL_mod_final),
         e = residuals(CEWL_mod_final))
```


Linearity and Equal Variance

Is the function **linear**? Is there **equal** variance of the residuals? The residuals should be homoskedactic relative to y_hat (or x). We don't care if there is a relationship between the residuals ~ dependent variable (actual y).

Plotting residuals shows us whether the data meets linearity and equal variance assumptions:

```{r}
ggplot(data = CEWL_t_mod_res, aes(x = y_hat, y = e)) +
  geom_point() + 
  theme_classic() + 
  xlab("predicted y (y-hat)") +
  ylab("residuals (e)") +
  ggtitle("CEWL Model 13 Residuals") +
  geom_hline(yintercept = 0)
```

It looks much much better. :) Equal error variance doesn't look perfect, but there's no more fan shape.

Brown-Forsythe test to statistically check equal variance:

H0: normally distributed (non-sig test is GOOD)
HA: NOT normally distributed (reject nul == assumption not satisfied)

```{r}
# need to create the right data & format first
bf_data_CEWL_t <- CEWL_t_mod_res %>%
  dplyr::mutate(middle_mass = median(mass_g), # mass
                side_mass = as.factor(mass_g > middle_mass),
                # solar radiation
                middle_sorad = median(Solar_rad_Wm2_interpol),
                side_sorad = as.factor(Solar_rad_Wm2_interpol > middle_sorad), 
                # temperature
                middle_temp = median(temp_C_interpol),
                side_temp = as.factor(temp_C_interpol > middle_temp),
                # VPD
                middle_absh = median(VPD_kPa_int),
                side_absh = as.factor(VPD_kPa_int > middle_absh),
                middle_ct = median(cloacal_temp_C),
                side_ct = as.factor(cloacal_temp_C > middle_ct)
                )


# now run test
bf.test(formula = e ~ side_absh, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_temp, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_sorad, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_ct, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
bf.test(formula = e ~ side_mass, # y~x
        data = bf_data_CEWL_t, # dataframe
        alpha = 0.05, # default 0.05
        na.rm = TRUE, # remove missing data before running?
        verbose = TRUE # print output to console?
        )
```

Equal variance is still satisfied for all continuous predictor variables.


Now check normality. Is the distribution of residuals **normal**?

use Shapiro-Wilk normality test:
H0: data is NOT significantly different from normal distribution
HA: data IS significantly different from normal distribution

```{r}
simple.eda(CEWL_t_mod_res$e)
shapiro.test(CEWL_t_mod_res$e)
```

Still not statistically normal... but the distribution looks a lot better.


### Conclusion

The best CEWL model should use log-transformed CEWL because this greatly improves the model based on AIC and it allows the model to satisfy the linearity assumption of LMM. 

```{r}
# save log model 3 summary object
CEWL_best_t_mod <- broom.mixed::tidy(CEWL_mod_final)
# export 
write.csv(CEWL_best_t_mod, "./best models/CEWL_best_mod_t_vals.csv")
```


## Multicollinearity


# What to Present in the Paper

- figures (exported)
- hct SLR
- best osml mod
- best CEWL mod (CEWL log-transformed)

